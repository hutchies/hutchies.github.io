<!doctype html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://code.jquery.com/mobile/1.4.5/jquery.mobile-1.4.5.min.css" />
<script src="https://code.jquery.com/jquery-1.11.1.min.js"></script>
<script src="https://code.jquery.com/mobile/1.4.5/jquery.mobile-1.4.5.min.js"></script>
<!--<meta name="viewport" content="width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">-->
<style>
.current-bar {
  color: black;
  font-weight: bold;
}

.current-beat {
  color: red;
}

.not-current {
  color: grey;
}

.bar:hover {
  color: blue;
  cursor: pointer;

.bars {
  border: 0px;
}
}
</style>
<script src="fraction/fraction.js"></script>
<!--<script src="metronome/metronome.js"></script>-->
<script src="metronome/worker.js"></script>
<script src="metronome/monkeypatch.js"></script>
<script src="pako.js"></script>
<script src="mespeak.js"></script>
<script>

var audioContext = null;
var isPlaying = false;      // Are we currently playing?
var startTime;              // The start time of the entire sequence.
var lookahead = 25.0;       // How frequently to call scheduling function
                            //(in milliseconds)
var scheduleAheadTime = 0.1;    // How far ahead to schedule audio (sec)
                            // This is calculated from lookahead, and overlaps
                            // with next interval (in case the timer is late)
var nextNoteTime = 0.0;     // when the next note is due.
var noteLength = 0.05;      // length of "beep" (in seconds)
var timerWorker = null;     // The Web Worker used to fire timer messages
var masterVolume = 0.5;
var real_bar_number = 1;
var current_bar = 0; // Will need to tweak for count-ins and to respect written bar numbers
var current_beat = 0;
var working_bars = [];
var loop = true;
var reset_bn_on_loop = false;
var tempo_percent = 100;
var speech = false;

var rhythm = {
  crotchet: Fraction(4,1),
  quaver: Fraction(8,1),
  minim: Fraction(2,1),
  semibreve: Fraction(1,1),
  semiquaver: Fraction(16,1),
  demisemiquaver: Fraction (32,1),
  tuplet: function(how_many, in_time_of, unit){
    //return ito_unit.mul(how_many).div(hm_unit.mul(in_time_of));
    return Fraction(how_many, in_time_of).mul(unit);
  },
  triplet: function(unit){
    return this.tuplet(3, 2, unit);
  },
  dot: function(unit){
    return this.tuplet(2, 3, unit);
  },
  fromText: function(text){
    //var text = t.trim(); // Just in case
    if(/[0-9]+/.test(text)){
      // Simple American style
      return Fraction(text, 1);
    }else{
      text = text.trim(); // Just in case
      switch(text){
        case 'sb':
          return rhythm.semibreve;
          break;
        case 'm':
          return rhythm.minim;
          break;
        case 'c':
          return rhythm.crotchet;
          break;
        case 'q':
          return rhythm.quaver;
          break;
        case 'sq':
          return rhythm.semiquaver;
          break;
        case 'ds':
          return rhythm.demisemiquaver;
          break;
        case 'hd':
          return rhythm.hemidemisemiquaver;
          break;
        alert('Incompatible rhythmic type; reverting to crotchet');
        return rhythm.crotchet;
      }
    }
  }
}

function tempo_to_string(tempo, british = true){
  var unit = tempo.unit;
  var bpm = tempo.bpm;
  console.log("making string of "+tempo.unit+" and "+tempo.bpm);

  if(!british){
    return unit.toString() + "=" + bpm;
  }else{
    var unit_s;
    switch(unit){
      case rhythm.semibreve:
        unit_s = 'sb';
        break;
      case rhythm.minim:
        unit_s = 'm';
        break;
      case rhythm.crotchet:
        unit_s = 'c';
        break;
      case rhythm.quaver:
        unit_s = 'q';
        break;
      case rhythm.semiquaver:
        unit_s = 'sq';
        break;
      case rhythm.demisemiquaver:
        unit_s = 'ds';
        break;
      case rhythm.hemidemisemiquaver:
        unit_s = 'hd';
        break;
      default:
        unit_s = unit.toString();
        break;
    }
    return unit_s + "=" + bpm;
  }
}

function Tempo(unit, bpm){
  this.unit = unit;
  this.bpm = bpm;

  /*this.makeString = function(british = true){
    console.log("making string of "+this.unit+" and "+this.bpm);

    if(!british){
      return this.unit.toString() + "=" + this.bpm;
    }else{
      var unit_s;
      switch(this.unit){
        case rhythm.semibreve:
          unit_s = 'sb';
          break;
        case rhythm.minim:
          unit_s = 'm';
          break;
        case rhythm.crotchet:
          unit_s = 'c';
          break;
        case rhythm.quaver:
          unit_s = 'q';
          break;
        case rhythm.semiquaver:
          unit_s = 'sq';
          break;
        case rhythm.demisemiquaver:
          unit_s = 'ds';
          break;
        case rhythm.hemidemisemiquaver:
          unit_s = 'hd';
          break;
        default:
          unit_s = this.unit.toString();
          break;
      }
      return unit_s + "=" + this.bpm;
    }
  }*/
}

function str_metre(str){
  var [n, d] = str.split("/");
  return new Metre(n, d);
}

function metre_str(metre){
  if(typeof metre == "string") return metre; // No conversion needed!
  return metre.num + "/" + metre.denom;
}

function Metre(num, denom){
  this.num = num;
  this.denom = Fraction(denom); // will this work with alternatives?
  this.click_bpm = function(tempo){
    return Fraction(tempo.bpm).div(tempo.unit).mul(this.denom);
  }
  this.bar_bpm = function(tempo){
    return Fraction(this.click_bpm(tempo), this.num);
  }
}

var default_tempo = new Tempo(rhythm.crotchet, 120);
var default_metre = new Metre(4, 4);

var current_params = {
  tempo: default_tempo,
  metre: default_metre
}

var m = [
  {
    metre: "4/4",
    bars: 10
  }
];

function unroll(rolled){
  var unrolled = [];
  var working_tempo = default_tempo;
  var working_metre = default_metre;
  for (block of rolled){
    //console.log("Block info: "+JSON.stringify(block));
    var b = {};
    if(block.tempo !== undefined){
      console.log("Has tempo");
      working_temppo = block.tempo;
    }
    b.tempo = working_tempo;
    if(block.metre !== undefined){
      console.log("Has metre");
      if(typeof block.metre == "string"){
        working_metre = str_metre(block.metre);
      }else{
        working_metre = block.metre;
      }
    }
    if(block.rehearsal !== undefined){
      b.rehearsal = block.rehearsal;
    }
    b.metre = working_metre;
    if(block.bars > 1){
      for(let i = 0; i < block.bars; i++){
        if(i > 0){
          if(b.rehearsal !== undefined){
            // Only mark rehearsal mark on first bar
            b = Object.assign({}, b); // Clone
            delete b.rehearsal;
          }
        }
        unrolled.push(b);
      }
    }else{
      unrolled.push(b);
    }
  }
  return unrolled;
}

function metronome_init(){
  audioContext = new AudioContext();
  timerWorker = new Worker("metronome/worker.js");

  timerWorker.onmessage = function(e) {
    if (e.data == "tick") {
      //console.log('tick');
      scheduler();
    } else {
      console.log("message: " + e.data);
    }
  };

  timerWorker.postMessage({"interval":lookahead});
}

function reset_metronome(){
}

function scheduler() {
  //console.log("Scheduler called: nnt="+nextNoteTime+", cT="+audioContext.currentTime+", saT="+scheduleAheadTime);
  while (nextNoteTime < audioContext.currentTime + scheduleAheadTime ) {
    //console.log("Scheduling next note");
    scheduleNote(current_beat, nextNoteTime);
    next_beat();
  }
}

function max_beats(){
  var beats = working_bars[current_bar].metre.num; // what about subdivisions?
  return beats;
}

/*function set_params(){ // !! Should be unnecessary!
  var b = working_bars[current_bar];
  //console.log("Bar "+current_bar+", tempo "+b.tempo+", metre "+b.metre);
  if(b.tempo !== undefined){
    //console.log("New tempo info");
    current_params.tempo = b.tempo;
  }
  if(b.metre !== undefined){
    //console.log("New metre info");
    current_params.metre = str_metre(b.metre);
  }
}*/

function next_bar(){
  current_beat = 0;
  current_bar++;
  real_bar_number++;
  if(current_bar >= working_bars.length){ // running out of track
    if(loop){
      current_bar = 0;
      if(reset_bn_on_loop){
        real_bar_number = 1;
      }
    }else{
      play(); //i.e. stop â€“ change!!
      return; //avoid any crashes on basis of current_bar being too big
    }
  }
  //set_params(); //Update with current bar
}

function next_beat(){
  var percent = Fraction(100).div(tempo_percent);
  //console.log(JSON.stringify(working_bars[current_bar].metre));

  // We are actually scheduling the next beat here, so highlight the last one (bit of a cheat I know)
  highlight_beat();

  var secondsPerBeat = Fraction(60).div(working_bars[current_bar].metre.click_bpm(working_bars[current_bar].tempo)).mul(percent);
    nextNoteTime += secondsPerBeat.valueOf();    // Add beat length to last beat time
    current_beat++;    // Advance the beat number, wrap to zero

    if (current_beat == max_beats()) {
      next_bar();
    }

}

function calc_sound(beat){
  if(beat == 0){
    return {vol: masterVolume, pitch: 2};
  }
  return {vol: masterVolume * 0.75, pitch: 1};
}

function scheduleNote(beatNumber, time){
  // create oscillator & gainNode & connect them to the context destination
  var sound = calc_sound(beatNumber);

  if(!speech){ // Do as click not speech

    var osc = audioContext.createOscillator();
    var gainNode = audioContext.createGain();

    osc.connect(gainNode);
    gainNode.connect(audioContext.destination);

    osc.frequency.value = sound.pitch*440;
    gainNode.gain.value = sound.vol;

    osc.start(time);
    osc.stop(time + noteLength);
  }else{ // Speak
    //var speech_wav = meSpeak.speak(beatNumber+1, {pitch: sound.pitch * 50, volume: sound.vol, rawdata: true});
    //var gainNode = audioContext.createGain();
    //gainNode.gain.value = sound.vol;
    //gainNode.connect(audioContext.destination);
    var source = audioContext.createBufferSource();
    //var buff = audioContext.createBuffer(1, )
    beat_speech = meSpeak.speak(beatNumber+1, {pitch: sound.pitch * 50, volume: sound.vol, speed: 200, rawdata: 'wav'});
    //meSpeak.speak(beatNumber+1, {pitch: sound.pitch * 50, volume: sound.vol});
    audioContext.decodeAudioData(beat_speech, function(buffer){
      source.buffer = buffer;
      source.connect(audioContext.destination);
      source.start(time);
    });

    //source.start(time);
  }
}

function create_table(b){
  var bars = unroll(b);
  //var html = $('table');
  var html = '<table class="bars">';
  var bn = 0;
  for(bar of bars){
    //var row = $('tr');
    var real_bn = bn+1;
    var reh = "<td></td>"; // Default for no rehearsal mark
    if(bar.rehearsal !== undefined){
      console.log('found mark '+bar.rehearsal);
      reh = '<td id="reh-'+bar.rehearsal+'"><b>('+bar.rehearsal+')</b></td>';
    }
    var row = '<tr class="bar" id="bar-'+bn+'">'+reh+'<td class="bar_num">'+real_bn+": </td>";

    for(let i = 0; i < bar.metre.num; i++){
      //console.log("beat-"+bn+'-'+i);
      var col = '<td id="beat-'+bn+'-'+i+'"> &bull; </td>';
      //var col = $('td').append(i);
      //row.append(col);
      row += col;
    }
    html += row+"</tr>";
    //html.append(row);
    bn++;
  }
  html += "</table>";
  //console.log(html);
  $('#beat_table').html(html);
  $('.bar').on('click', function(){
    console.log(this);
    var id = $(this).attr('id');
    var [scrap, num] = id.match(/bar-([0-9]+)/);
    if(num != undefined){
      current_bar = num;
      current_beat = 0;
      highlight_beat();
    }
  });
}

function highlight_beat(){
  $('.current-beat').removeClass('current-beat');
  $('#beat-'+current_bar+"-"+current_beat).addClass('current-beat');

  $('.current-bar').removeClass('current-bar');
  $('#bar-'+current_bar).addClass('current-bar');

  //console.log($('#beat-'+current_bar+"-"+current_beat));
}

function play() {
  isPlaying = !isPlaying;

  //audioContext = new AudioContext(); // Here so it is from a tap for Safari
  //audioContext = window.AudioContext || window.webkitAudioContext; // Here so it is from a tap for Safari

  audioContext.resume();

  if (isPlaying) {

    working_bars = unroll(m);

    current_beat = 0;
    //current_bar = 0;
    real_bar_number = current_bar + 1;
    //set_params();

    $('#beat_table').addClass('not-current');
    highlight_beat();

    if(speech){
      // prime speech to save rhythm
      var scrap = meSpeak.speak("test", {rawdata: 'wav'});
    }

    nextNoteTime = audioContext.currentTime;
    timerWorker.postMessage("start");
    document.getElementById("play").innerHTML = "Pause";
    $('#reset').removeClass('ui-disabled');
  } else {

    $('#beat_table').removeClass('not-current');


    timerWorker.postMessage("stop");
    document.getElementById("play").innerHTML = "Play";
    $('#reset').addClass('ui-disabled');
  }
}

function speech_init(){
  meSpeak.loadConfig("mespeak_config.json");
  meSpeak.loadVoice('en.json');
}

function copy_url(){
  $('#gz_url').select();
  document.execCommand("copy");
}

function mirror_structure(){
  // Display structure of m in edit_structure field

  var display_string = '';

  for(i in m){
    var metre = m[i].metre;
    var tempo = m[i].tempo;
    var rehearsal = m[i].rehearsal;
    var bars = m[i].bars;

    var metre_s = '';
    var tempo_s = '';
    var bars_s = '';
    var rehearsal_s = '';

    // Make sure all have meaningful values, carrying if needed
    if(metre != undefined){
      metre_s = metre_str(metre)+' ';
    }else if(i == 0){
      // Just use default on first time
      metre_s = metre_str(default_metre)+' ';
    }

    if(tempo != undefined){
      tempo_s = tempo_to_string(tempo, true)+' ';
    }else if(i == 0){
      tempo_s = tempo_to_string(default_tempo, true)+' ';
    }

    if(rehearsal != undefined){
      rehearsal_s = rehearsal + ": ";
    }

    if(bars > 1){
      bars_s = 'x' + bars + ' ';
    }

    // Now load up for display in canonical order
    if(i > 0){
      if(rehearsal != undefined){
        display_string += "\n";
      }else{
        display_string += ", "; // avoid too many newlines
      }
    }
    var temp_string = rehearsal_s + tempo_s + metre_s + bars_s
    display_string += temp_string.trim();
  }
  $('#edit_structure').val(display_string);
}

function revert_old(){
  mirror_structure();

}

function load_new(){
  // Parse edit_structure field and load to m
  // Need to check that all rehearsal marks are unique (and offer to number them?)
  // Also need to load up rehearsal mark jump div if there are any

  var text = $('#edit_structure').val();
  var lines = text.split(/[,\n]/);
  m = [];
  for(i in lines){
    var units = lines[i].trim().split(/\s+/);
    var metre = undefined, tempo = undefined, rehearsal = undefined, bars = undefined;
    var b = {};

    for(j in units){
      //console.log("''"+units[j]+"''");
      if(/^[^:]+:$/.test(units[j])){
        rehearsal = units[j].slice(0,-1);
        continue;
      }
      if(/^x[0-9]+$/.test(units[j])){
        bars = units[j].slice(1);
        continue;
      }
      if(/^[0-9]+\/[0-9+]$/.test(units[j])){
        metre = units[j];
        continue;
      }
      if(/^[0-9sbmcqdh]+=[0-9]+$/.test(units[j])){
        var [scrap, r, bpm] = units[j].match(/^([0-9sbmcqdh]+)\=([0-9]+)$/);
        console.log('found rhythm '+r+' and bpm '+bpm);
        tempo = new Tempo(rhythm.fromText(r), bpm);
      }
    }

    if(metre != undefined){
      b.metre = metre;
    }
    if(rehearsal != undefined){
      b.rehearsal = rehearsal;
    }
    if(tempo != undefined){
      b.tempo = tempo;
    }
    if(bars != undefined){
      console.log('not undefined: '+bars);
      b.bars = bars;
    }
    m.push(b);
  }

  m_changed();
}

function m_changed(){
  // Things to do every time m changes

  mirror_structure(); // to make sure it is displayed canonically (good idea or not?)
  set_gzipped();
  create_table(m);
}

function set_gzipped(){
  var compressed = pako.deflateRaw(JSON.stringify(m), {to: 'string'});
  $('#gz_url').val("http://hutchies.github.io/metronome.html?sequence="+encodeURIComponent(compressed));
}

$(document).ready(function(){

  $('#play').on('click', play);
  $('#reset').on('click', reset_metronome);
  $('#copy').on('click', copy_url);
  $('#edit_done').on('click', load_new);
  $('#edit_revert').on('click', revert_old);
  //$('#process').on('click', process_tempi);
  metronome_init();
  speech_init();

  var urlParams = new URLSearchParams(window.location.search);

  //alert(urlParams);

  if(urlParams.has('sequence')){
    console.log('launched from existing sequence');
    var sequence = decodeURIComponent(urlParams.get('sequence'));
    var infl = pako.inflateRaw(sequence, {to: 'string'});
    m = JSON.parse(infl);
    $('#play_link').click();

    m_changed();
    //mirror_structure();
  }

  //$('#reset').button('disable');
  //$('#reset').button('refresh');
  //$('#reset').disabled = true;

  m_changed();
});

$(document).on('pageinit', function(){
  mirror_structure(); // So that it autogrows to size
});
</script>
</head>
<body>
  <div data-role="tabs" id="tabs">
    <div data-role="navbar">
      <ul>
        <li><a href="#editing" class="ui-btn-active ui-state-persist" data-ajax="false">Edit</a></li>
        <li><a id="play_link" href="#playback" data-ajax="false">Play</a></li>
        <li><a href="#export" data-ajax="false">Export</a></li>
      </ul>
    </div>
  <div id="editing" class="ui-content">
      <label for="edit_structre">Edit structure here:</label>
      <textarea id="edit_structure" cols="50" rows="20" style = "overflow: auto;"></textarea>

      <button id="edit_revert">Revert to previous version</button>
      <button id="edit_done">Load edited version</button>

    <h3>Guide</h3>
    Enter metronome events either on separate lines or separated by commas. Each metronome event consists of any combination of the following separated by spaces:
    <ul>
      <li><b>A:</b> (i.e. letter plus colon) &ndash; a rehearsal mark</li>
      <li><b>3/4</b> (i.e. two numbers with a / between) &ndash; a metre indication (defaults to previous metre)</li>
      <li><b>x3</b> (i.e. an x and a number) &ndash; how many bars this lasts for (default 1)</li>
      <li><b>c=120</b> (i.e. a rhythm unit &ndash; see below, = and a number) &ndash; a tempo marking. Rhythm units are as follows:
        <ul>
          <li>sb or 1: semibreve or whole note</li>
          <li>m or 2: minim or half note</li>
          <li>c or 4: crotchet or quarter note</li>
          <li>q or 8: quaver or eighth note</li>
          <li>sq or 16: semiquaver or 16th note</li>
          <li>ds or 32: demisemiquaver or 32nd note</li>
          <li>hd or 64: hemidemisemiquaver or 64th note (numbers continue after this indefinitely)</li>
        </ul>
      </li>
    </ul>
    v 1.02 (4 Jan 2019 3:05pm)
  </div>
  <div id="playback" class="ui-content">
    <div class="ui-body ui-body-a ui-corner-all">
    <h3>Playback options</h3>
    <button data-inline="true" id="play">Play</button>
    <button data-inline="true" class="ui-disabled" id="reset">Reset</button>
    <div id="play_reh"></div>
<div data-role="fieldcontain">
    <label for="percent">Play at % of final tempo (still needs wiring in):</label>
    <input type="range" name="percent" id="percent" value="100" min="1" max="200" />
  </div>
  <div data-role="collapsible">
    <h4>Advanced options</h4>
  </div>
</div>
<div class="ui-body ui-body-a ui-corner-all">
<h3>Piece structure:</h3>
Click a line to start metronome from there.
<div id="beat_table"></div>
  </div>
</div>
<div id="export" class="ui-content">
  <div>Encoded in URL format: <input id="gz_url" type="text"><button data-inline="true" id="copy">Copy</button></div>
</div>
</div>
</body>
</html>
