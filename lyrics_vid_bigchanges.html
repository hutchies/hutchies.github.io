<!DOCTYPE html>
<html lang="en">
<head>
  <title>Make a lyrics video</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
  <style>

  .line_text {
    display: inline-block;
    cursor: pointer;
    border-style: solid;
    border-width: 1px;
    border-color: blue;
    background-color: lightblue;
    font-size: 1em;
    white-space: pre-wrap;
  }
  .selected {
    background-color: pink;
  }

  .highlighted {
    background-color: lightgrey;
  }

  .subpanel {
    margin-left: 15px;
  }

  .impossible {
    color: grey;
  }

  #confirmation {
    color: green;
  }

  .lyrics_array {
    min-height:200px;
    border:1px solid #ccc;
    resize: both;
  }
  .floating_vid {
    position: fixed;
    top: 0;
    right: 0;
    z-index: 1;
  }
  #video_container {
    position: relative;
  }

  /* Tooltip container */
.percentage {
  position: relative;
  display: inline-block;
}

/* Tooltip text */
.percentage .tooltiptext {
  visibility: hidden;
  width: 120px;
  background-color: black;
  color: #fff;
  text-align: center;
  border-radius: 6px;
  padding: 5px 0;

  /* Position the tooltip */
  position: absolute;
  z-index: 1;
  bottom: 100%;
  left: 50%;
  margin-left: -60px;
  margin-bottom: 10px;
}

.percentage .tooltiptext::after {
  content: "";
  position: absolute;
  top: 100%;
  left: 50%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: black transparent transparent transparent;
}

/* Show the tooltip text when you mouse over the tooltip container */
.percentage:hover .tooltiptext {
  visibility: visible;
}

  input[type="number"]{
    width: 4em;
  }

  #vid {
    margin-bottom: -5px;
  }
  #preview_container {
    position: absolute;
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100%;
    bottom: 0;
    pointer-events: none;
  }
  #placeholder {
    position: absolute;
    left: 0;
    bottom: 0;
    z-index: -1;
  }
  #canvas {
    z-index: 5;
  }
  audio {
    position: absolute;
    left: 0;
    bottom: 0;
    pointer-events: auto;
  }
  .time {
    cursor: pointer;
    color:blue;
    text-decoration: underline;
  }
  .delete {
    cursor: pointer;
    color:red;
    text-decoration: underline;
  }
  .lyrics_text {
    cursor: pointer;
    white-space: pre-wrap;
  }

  .single_line_container {
    vertical-align: top;
  }

  table, td {
    border: 1px solid grey;
    border-collapse: collapse;
  }


  #size_warning {
    color: red;
    font-style: bold;
  }

  hr {
    border: 1px solid black;
  }

  details{
    background-color: lightgrey;
    padding: 4px;
  }

  details > p {
    margin: 10px;
  }

  </style>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
  <script src="mousetrap.min.js"></script>
  <script src="jszip.min.js"></script>
  <script>
  $(document).ready(function() {
    window.selected_line = -1;
    window.timecodes = [];
    window.ids = 0;
    window.undo_buffer = [];
    window.video = document.getElementById('vid');
    window.last_timecode = -1;
    window.redo_buffer = [];
    window.prev_list_length = 0;
    window.test_canvas = document.createElement('CANVAS');
    //window.running_locally = false;
    window.vid_name = '[novideo]';
    window.is_audio = false;
    window.img_type = 'tiff';
    window.cached_canvases = {};
    window.is_mouse_down = false;
    $(document).mouseup(e => {window.is_mouse_down = false; return true;});
    /*$(document).mousedown((e) => {
        $('.highlighted').each(function(e){this.className = ''});
        $('#selected_options').hide();
    });*/
    window.isWorkerLoaded = false;
    window.worker_promise = {};
    window.worker = null;
    window.ffmpeg_running = false;
    window.cached_sizes = {width: 0, height: 0};
    window.current_style = "default";

    window.percentage_fields = ['bg_width', 'h_offset', 'v_offset', 'h_margin', 'v_margin', 'font_size', 'video_size'];
    window.preview_line = {start: 0, end: 0, text: ''};
    $('#process').on('click', process_lyrics);
    $('#clear').on('click', function(){
      $('#lyrics').val('');
    });
    $('#clear_board').on('click', function(){
      $('#lyrics_array').html('');
      end_lyric(timecode());
    });
    $('#sub_file').on('change', function(evt){
      if(window.timecodes.length > 0){
        if(!confirm('Are you sure you want to load a new set of subs and wipe existing timings?')) return;
      }
      var f = this.files[0];
      const reader = new FileReader();
      reader.addEventListener('load', (event) => {
        load_subs(event.target.result);
      });
      reader.readAsText(f);
    });
    $('#save_subs').on('click', save_subs);
    $('#vid_file').on('change', function(evt){
      var f = this.files[0];
      window.vid_name = f.name;
      if(f.type.match('video.*')){
        window.is_audio = false;
        $('#video_container').html('<video playsinline id="vid" controls="true"><source id="video_here" />Your browser does not support HTML5 video.</video><div id="preview_container"><canvas id="canvas">Your browser does not support HTML canvas.</canvas></div>');
        $('#video_here')[0].src = URL.createObjectURL(f);
        //$('#video_proportions').show();
        window.video = document.getElementById('vid');
        $('#vid').on('canplay', vid_ready); // Reinstate events
        $('#vid').on('timeupdate', timeupdate); // Reinstate events
        $('#audio_settings').hide();
      }else if(f.type.match('audio.*')){
        window.is_audio = true;
        $('#video_container').html('<div id="preview_container"><canvas id="placeholder">No Canvas support.</canvas><audio id="vid" controls="true"><source src="https://files.freemusicarchive.org/storage-freemusicarchive-org/music/WFMU/Broke_For_Free/Directionless_EP/Broke_For_Free_-_01_-_Night_Owl.mp3" id="video_here" />Your browser does not support HTML5 audio.</audio><canvas id="canvas">No Canvas support.</canvas></div>');
        $('#video_here')[0].src = URL.createObjectURL(f);
        window.video.videoWidth = 1024; // Placeholder to stop breakage
        window.video.videoHeight = 768; // Placeholder to stop breakage
        $('#vid').on('canplay', vid_ready); // Reinstate events
        $('#vid').on('timeupdate', timeupdate); // Reinstate events
        window.video = document.getElementById('vid');
        $('#audio_settings').show();
        $('.resize_vid').on('change', resize_vid_for_audio);
        $('#placeholder').css('width', 1024 * video_size_mult());
        $('#placeholder').css('height', 768 * video_size_mult());
        $('#placeholder')[0].width = 1024;
        $('#placeholder')[0].height = 768;
      }

      $('#video_here').parent()[0].load();
    });
    $('#vid').on('canplay', vid_ready);
    Object.defineProperty(HTMLMediaElement.prototype, 'playing', {
        get: function(){
          return !!(this.currentTime > 0 && !this.paused && !this.ended && this.readyState > 2);
        }
    })
    $('#vid').on('timeupdate', timeupdate);
    $('#home_ffmpeg').on('click', home_ffmpeg);
    $('#export_srt').on('click', export_srt);
    $('#export_ass').on('click', export_ass);
    $('.instructions').hide();
    $('#audio_settings').hide();
    $('.fit_to_screen').hide();
    $('#bible_version').on('change', bible_version);
    $('#bible_custom').hide();
    $('#add_verse').on('click', add_verse);
    $('.options').hide();
    $('#float').on('click', float_video);
    $('.opt_control').on('change', change_opt);
    $('.opt_control').on('input', change_opt);
    $('.slider').on('input', adjust_range);
    $('.percentage').mouseover(show_percentage);
    $('#browser_overlay').on('click', export_overlay);
    $('#browser_overlay').hide();
    $('#browser_full').on('click', export_full);
    $('#browser_full').hide();
    $('#selected_options').hide();
    $('#split_lyric').on('click', split_selected);
    $('#join_lyric').on('click', join_selected);
    $('#split_lyric').hide();
    $('#deselect_lyric').hide();
    $('#lyrics_array').on('mousedown', '.line_text', click_line);
    $('#list').on('click', '.delete', delete_sub);
    $('#list').on('click', '.lyrics_text', edit_lyric);
    $('#list').on('change', '.lyrics_style', change_lyric_style);
    $('#list').on('click', '.time', click_time);
    isHighlighted = false;
    $("#list").on('mousedown', '.lyrics_text', function (evt) {
      if(!evt.shiftKey) return;
      //console.log(this);
      window.is_mouse_down = true;
      $(this).toggleClass("highlighted");
      isHighlighted = $(this).hasClass("highlighted");
      if($('.highlighted').length > 0){
        $('#selected_options').show();
      }else{
        $('#selected_options').hide();
      }
      return false; // prevent text selection
    })
    .on('mouseover', '.lyrics_text', function (evt) {
      if(!evt.shiftKey) return;
      if (window.is_mouse_down) {
        $(this).toggleClass("highlighted", isHighlighted);
      }
      if($('.highlighted').length > 0){
        $('#selected_options').show();
      }else{
        $('#selected_options').hide();
      }
    });
    $('#deselect_lyric').on('click', end_lyric_now);
    $('#join_lyric').hide();
    $('#show_log').on('click', function(){
      if($('#show_log').is(':checked')){
        $('#ffmpeg_log').show();
      }else{
        $('#ffmpeg_log').hide();
      }
    });
    $('#ffmpeg_log').hide();
    if(storageAvailable('localStorage')){
      $('#save_opts').on('click', save_opts);
      $('#reset_opts').on('click', load_opts);
      $('#wipe_opts').on('click', wipe_opts);
      $('#save_codec').on('click', save_codec);
      load_opts();
      load_codec();
      check_autosave();
    }else{
      $('#saving').hide();
      $('#save_codec').hide();
      init_opts();
    }
    set_opt_controls();
    display_opts();
    $('#lyrics').on('keydown', function(e){
      if(e.which === 13 && e.ctrlKey){
        process_lyrics();
        return false;
      }
    });
    $('#single_line').on('keydown', function(e){
      //console.log(count_occ($('#single_line').val(), '\n'));
      if(e.which === 13 && $('.verse_opts').is(':visible')){
        // In verse bit!
        add_verse();
        return false;
      }
      if(e.which === 13 && count_occ($('#single_line').val(), '\n') >= window.opts._global.subtitle_lines - 1){
        add_line();
        return false;
      }
    });
    $('#add').on('click', add_line);
    $('#ffmpeg').hide();
    //$('#list_div').hide();
    $('#ffmpeg_info').hide();
    init_worker();
    Mousetrap.bind('space', function(e){
      if (e.preventDefault) {
        e.preventDefault();
      } else {
        // internet explorer
        e.returnValue = false;
      }
      playpause();
    });
    Mousetrap.bind('down', function(e){
      if (e.preventDefault) {
        e.preventDefault();
      } else {
        // internet explorer
        e.returnValue = false;
      }
      next_lyric();
    });
    Mousetrap.bind('up', function(e){
      if (e.preventDefault) {
        e.preventDefault();
      } else {
        // internet explorer
        e.returnValue = false;
      }
      prev_lyric();
    });
    Mousetrap.bind('mod+z', undo);
    Mousetrap.bind('mod+shift+z', redo);
    Mousetrap.bind(['del', 'backspace', 'esc'], end_lyric_now);
    $('#undo_button').click(undo);
    $('#redo_button').click(redo);
    $('#undo_button').hide();
    $('#redo_button').hide();
    $('#lyrics').focus();

    Mousetrap.prototype.stopCallback = function(e, element, combo) {
      if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {
        if(combo != 'space' && combo != 'backspace' && combo != 'del') return false;
      }

      // stop for input, select, and textarea
      return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || (element.contentEditable && element.contentEditable == 'true');

    }
    $('.styles_list').on('change', switch_style);
    $('#make_style').on('click', make_style);
    $('#delete_style').on('click', delete_style);
    $('#delete_all').on('click', delete_all_subtitles);
    //console.log(tallest_height());
  });

  function update_percentage(id){
    var real = 0;
    var plural = 's';
    if(id == 'font_size'){
      real = fs_in_px().toFixed(0);
    }else if(id == 'video_size'){
      var x = window.video.videoWidth * video_size_mult();
      var y = window.video.videoHeight * video_size_mult();
      real = x.toFixed(0) + ' x ' + y.toFixed(0);
      if (x == 1 && y == 1) plural = '';
    }else if(id == 'h_offset' || id == 'bg_width' || id == 'h_margin'){
      real = proportion('width', window.opts[window.current_style][id]).toFixed(0);
      if(real == 1) plural = '';
    }else if(id == 'v_offset' || id == 'v_margin'){
      real = proportion('height', window.opts[window.current_style][id]).toFixed(0);
      if(real == 1) plural = '';
    }
    real += ' pixel' + plural;
    //console.log($('#'+id+'_range').siblings('.tooltiptext'));
    $('#'+id+'_range').siblings('.tooltiptext').text(real);
  }

  function show_percentage(){
    var id = $(this).children('.slider').attr('id').slice(0, -6);
    update_percentage(id);
  }

  function video_size_mult(){
    return window.opts._global.video_size / 100;
  }

  function delete_all_subtitles(){
    if(!confirm('This cannot be undone. Are you sure?')) return;
    window.timecodes = [];
    window.undo_buffer = [];
    window.redo_buffer = [];
    $('#list').html('');
    update_lyrics();
    //update_list?
  }

  function check_autosave(){
    var tc = localStorage.getItem('autosave');
    if(tc){
      load_subs(tc);
      localStorage.removeItem('autosave');
      alert('Your subtitles were autosaved and have been restored.');
      $('#autosave').show();
    }else{
      $('#autosave').hide();
    }
  }

  function setup_styles(){
    $('.styles_list').html(style_options());
    $('.styles_list').val(window.current_style);
    $('#style_selected').html(style_options());
    if(window.current_style == 'default'){
      $('#delete_style').prop('disabled', true);
    }else{
      $('#delete_style').prop('disabled', false);
    }
  }

  function end_lyric_now(){
    end_lyric(timecode());
  }

  function make_style(){
    var name = $('#new_style_name').val();
    $('#new_style_name').val('');
    name = name.replace(/[^A-Za-z0-9]/g, '');
    if(name === '') return;
    if(name in window.opts) return; // Can't make a second style of same name
    var style_content = Object.assign({}, window.opts[window.current_style]);
    //console.log(style_content);
    window.opts[name] = style_content;
    //console.log(style_options());
    $('.lyrics_style').html(style_options());
    $('#styles_list').html(style_options(name));
    set_style(name);
    //update_list?
  }

  function resize_vid_for_audio(){
    var x = Number.parseInt($('#vid_x').val());
    var y = Number.parseInt($('#vid_y').val());
    window.video.videoWidth = x;
    window.video.videoHeight = y;
    display_opts();
  }

  function clear_cache(sub){
    if (sub.height) delete sub.height;
    if (sub.width) delete sub.width;
    if (sub.wrap) delete sub.wrap;
    var c = get_cached_canvas(sub);

    if(c){
      c.users.splice(c.users.indexOf(sub));
      if(c.users.length == 0) delete window.cached_canvases[sub.style || 'default'][sub.text];
    }
  }

  function prerender(){
    // Pre-render everything. See how much this slows things down...
    window.timecodes.forEach(function(e){
      if(!get_cached_canvas(e)) draw_subtitle(e, null);
    })
    //console.log(window.cached_canvases);
  }

  function clear_style_cache(style, resize = true){
    if(window.cached_canvases[style]) delete window.cached_canvases[style];
    if(resize) window.timecodes.filter(tc => tc.style == style).forEach(tc => clear_cache(tc));
  }

  function delete_style(){
    var style = $('#styles_list').val();
    if(style == 'default'){
      return; // Can't delete default style, anyway shouldn't be possible as option is disabled
    }
    delete window.opts[style];
    clear_style_cache(style, true);
    window.timecodes.forEach(function(l, id){
      if(l.style == style){
        l.style = 'default';
        $('#style_'+id).val('default');
      }
      $('#style_'+id+" option[value='"+style+"']").remove();
      //console.log(l.style, style);
    });
    //console.log(window.timecodes);
  }

  function set_style(style){
    if(style != window.current_style){
      window.current_style = style;
      var li = lyric_index_at_time(timecode());
      if(li != -1){
        window.timecodes[li].style = style;
        clear_cache(window.timecodes[li]);
        $('#style_'+li).val(style);
        update_lyrics();
      }
    }
    setup_styles();
    opt_controls(style);
    check_text_width();
    //set_opt_controls();
  }

  function switch_style(){
    var style = $(this).val();
    $('.styles_list').val(style);
    set_style(style);
  }

  function preview_canvas(){
    //$('#preview').hide();
    //console.log(canvas);
    if(!window.previewing) window.previewing = 0;
    //console.log('previewing',window.previewing++);
    var c = document.getElementById('canvas');
    $(c).css('height', canvas_height() * video_size_mult() );
    draw_subtitle(window.preview_line, c);
    //check_text_width();
  }

  function display_opts(){
    size_video();
    preview_canvas();
  }

  function get_cached_canvas(line){
    let text = line.text || '';
    let style = line.style || 'default';
    //console.log(text,style);
    if(window.cached_canvases[style]) return window.cached_canvases[style][text];
    //console.log('need a fresh one');
    return false;
  }

  function add_cached_canvas(line, canvas){
    let text = line.text;
    let style = line.style || 'default';
    if(!window.cached_canvases[style]) window.cached_canvases[style] = {};
    if(!window.cached_canvases[style][text]){
      window.cached_canvases[style][text] = { canvas: canvas, users: [line]};
    }else{
      window.cached_canvases[style][text].users.push(line);
    }
  }

  function dec_cached_canvas(line){
    if(window.cached_canvases[style] && window.cached_canvases[style][text]){
      window.cached_canvases[style][text].users.splice(window.cached_canvases[style][text].users.indexOf(line));
      if(window.cached_canvases[style][text].users.length == 0) delete window.cached_canvases[style][text];
    }
  }

  function opt_controls(style){
    for(o in window.opts[style]){
      //console.log(o);
      var el = document.getElementById(o);
      if(!el) continue;
      if(el.getAttribute('type') == 'checkbox'){
        if(window.opts[style][o]){
          el.checked = true;
        }else{
          el.checked = false;
        }
      }else{
        el.setAttribute('value',window.opts[style][o]);
        let r = document.getElementById(o+'_range');
        if(r) r.value = window.opts[style][o];
        }
      }
      opt_constraints(o, window.opts[style][o]);
    }

  function set_opt_controls(){
    opt_controls(window.current_style);
    opt_controls('_global');
    setup_styles();
  }

  function openTab(evt, tabName, verse = 'place') {
    var i;
    var x = document.getElementsByClassName("tab_option");
    for (i = 0; i < x.length; i++) {
      x[i].style.display = "none";
    }
    tablinks = document.getElementsByClassName("tablink");
    for (i = 0; i < tablinks.length; i++) {
      tablinks[i].className = tablinks[i].className.replace(" w3-blue", "");
    }

    // Move lines control around
    document.getElementById(tabName).style.display = "block";
    evt.currentTarget.className += " w3-blue";

    if(tabName == 'place_lyrics'){
      if(verse == 'verse'){
        $('.verse_opts').show();
        $('.lyrics_opts').hide();
      }else{
        $('.verse_opts').hide();
        $('.lyrics_opts').show();
      }
    }
  }


  function goto_time(id){
    if(id.match(/start/)){
      var num = id.substring(6);
      window.video.currentTime = window.timecodes[num].start;
    }else if(id.match(/end/)){
      var num = id.substring(4);
      if(!window.timecodes[num].end) return;
      window.video.currentTime = window.timecodes[num].end;
    }
  }

  (function () {
    Blob.prototype.arrayBuffer = Blob.prototype.arrayBuffer || myArrayBuffer;

    function myArrayBuffer() {
      // this: File or Blob
      return new Promise((resolve) => {
        let fr = new FileReader();
        fr.onload = () => {
          resolve(fr.result);
        };
        fr.readAsArrayBuffer(this);
      })
    }
  })();

  function count_occ(str, sub){
    var i = -1, count = -1;
    do{
      i = str.indexOf(sub, i+1);
      count++;
    }while(i != -1);
    return count;
  }

  function add_undo(){
    window.undo_buffer.push(JSON.stringify(window.timecodes));
    if(window.redo_buffer.length > 0) $('#redo_button').hide(); // About to hide it
    window.redo_buffer = []; // Can't redo any more
    if(window.undo_buffer.length == 1) $('#undo_button').show(); // First one
  }

  function undo(){
    if(window.undo_buffer.length < 1) return;
    window.redo_buffer.push(JSON.stringify(window.timecodes));
    window.timecodes = JSON.parse(window.undo_buffer.pop());
    if(window.undo_buffer.length == 0) $('#undo_button').hide();
    if(window.redo_buffer.length == 1) $('#redo_button').show(); // First one
    update_list();
  }

  function redo(){
    if(window.redo_buffer.length < 1) return;
    window.undo_buffer.push(JSON.stringify(window.timecodes));
    window.timecodes = JSON.parse(window.redo_buffer.pop());
    if(window.redo_buffer.length == 0) $('#redo_button').hide();
    if(window.undo_buffer.length == 1) $('#undo_button').show(); // First one
    update_list();
  }

  function refresh(){

  }

  function delete_tc(i){
    $('#row_'+i).remove();
    //window.timecodes[i].
  }

  function tc_set_start(i, s){
    window.timecodes[i].start = s;
    $('#start_'+i).text(time_to_hms(s));
  }

  function tc_set_end(i, e){
    window.timecodes[i].end = e;
    $('#end_'+i).text(time_to_hms(e));
  }

  function set_time(id){
    if(id.match(/start/)){
      var num = id.substring(6);
      if(window.timecodes[num].start == window.video.currentTime) return;
      add_undo();
      tc_set_start(num, window.video.currentTime);
      check_overlap(num);
    }else if(id.match(/end/)){
      var num = id.substring(4);
      if(!window.timecodes[num].end){
        deselect();
      }else if(window.timecodes[num].end == window.video.currentTime){
        return;
      }
      add_undo();
      tc_set_end(num, window.video.currentTime);
      check_overlap(num);
    }
    sync_lyrics();
    //update_list? Should be called within check_overlap if needed
  }

  function num_round(num, places){
    return +num.toFixed(places);
  }

  function shunt_time(id){
    if(id.match(/start/)){
      var num = id.substring(6);
      var diff = num_round(window.video.currentTime - window.timecodes[num].start, 3);
      if(diff == 0) return;
      add_undo();
      for (let i = 0; i < window.timecodes.length; i++){
        // Move all of the timecodes by the same amount
        if(i >= num){
          tc_set_start(i, num_round(window.timecodes[i].start + diff, 3));
          tc_set_end(i, num_round(window.timecodes[i].end + diff, 3));
        }else if(diff < 0){
          // Just in moving start back, there is a chance that you will overwrite previous ones
          // So we need to check that
          var new_start = window.timecodes[num].start + diff;
          if(window.timecodes[i].start >= new_start){
            tc_set_start(i, window.timecodes[i].end); // so it will be deleted
          }
        }
      }
      check_overlap(num);
    }else if(id.match(/end/)){
      var num = id.substring(4);
      var diff = num_round(window.video.currentTime - window.timecodes[num].end, 3);
      if(diff == 0) return;
      add_undo();
      tc_set_end(num, window.video.currentTime);
      for (let i = num + 1; i < window.timecodes.length; i++){
        // num + 1 because we only want to change the end of window.timecodes[num]
        // Move all of the timecodes by the same amount
        tc_set_start(i, num_round(window.timecodes[i].start + diff, 3));
        tc_set_end(i, num_round(window.timecodes[i].end + diff, 3));
      }
      check_overlap(num);
    }
    sync_lyrics();
    //update_list? called via check_overlap if need be
  }

  function cut_overlaps(a){
    return a.map()
  }

  function check_overlap(i){
    // TODO this needs a proper rewrite... it's very messy
    var redrawing = false;
    //console.log('checking '+i,window.timecodes[i]);
    var intermediate = window.timecodes.filter(function(tc, tc_i){
      //console.log('filter: '+tc_i,tc);
      // Filter out impossibles or zero-length ones
      //if(tc_i == 1) //console.log(tc);
      if(tc.end <= tc.start){
        if(current_lyric() == tc_i) deselect();
        return false;
      }
      if(tc_i == i) return true; // Make sure we keep the one we are checking!
      if(tc.start >= window.timecodes[i].start && tc.end <= window.timecodes[i].end){
        if(current_lyric() == tc_i) deselect();
        return false;
      }
      return true;
    });

    if(window.timecodes.length != intermediate.length) redrawing = true;
    intermediate = intermediate.map(function(tc, tc_i){
      // Overlapping with start
      if(tc.start == window.timecodes[i].start && tc.end == window.timecodes[i].end) return tc; // Only possible if they are the same!
      if(tc.start <= window.timecodes[i].start && tc.end > window.timecodes[i].start){
        if(redrawing) tc.end = window.timecodes[i].start;
        else tc_set_end(tc_i, window.timecodes[i].start); // modifies window.timecodes directly
      }
      // Overlapping with end
      if(tc.start < window.timecodes[i].end && tc.end >= window.timecodes[i].end){
        if(redrawing) tc.start = window.timecodes[i].end;
        else tc_set_start(tc_i, window.timecodes[i].end); // modifies window.timecodes directly
      }
      return tc;
    });
    if(redrawing){
          //console.log('co', window.timecodes.length, intermediate.length);
      window.timecodes = intermediate;
      update_list();
    }
  }

  function delete_sub(){
    var id = $(this).attr('id').substring(7);
    if(current_lyric() == id) deselect();
    window.timecodes.splice(id, 1);
    update_list();
  }

  function float_video(){
    if($('#vc_container').hasClass('floating_vid')){
      // Reset
      $('#vc_container').removeClass('floating_vid');
      $('#float').text('Float video to right');
      $('#float').removeClass('w3-black');
      $('#float').addClass('w3-blue');
    }else{
      $('#vc_container').addClass('floating_vid');
      $('#float').text('Restore video');
      $('#float').removeClass('w3-blue');
      $('#float').addClass('w3-black');
    }
  }

  function vid_ready(){
    set_opt_controls(); // In case any depend on video info
    display_opts(); // Update for font size
    prerender();
  }

  function size_canvas(){
    $('#canvas').css('width', $('#vid').width());
    $('#canvas').css('height', canvas_height() * video_size_mult());
  }

  function size_video(){
    var vc = document.getElementById('video_container');
    var vid = document.getElementById('vid');
    if(vid.videoWidth == 0)  return; // Not ready yet
    $(vc).width(vid.videoWidth * video_size_mult()).height(vid.videoHeight * video_size_mult());
    $(vid).width($(vc).width());
    size_canvas();
    if(window.is_audio){
      $('#placeholder')[0].width = window.video.videoWidth;
      $('#placeholder')[0].height = window.video.videoHeight;
      $('#placeholder').css('width', $(vc).width());
      $('#placeholder').css('height', $(vc).height());
    }
  }

  function opt_constraints(opt, value){
    if(window.percentage_fields.includes(opt)) update_percentage(opt);
    if(opt == 'bg_visible'){
      if(value == true){
        $('#universal_overlay').prop('checked', true); // If bg is always visible, needs to be a consistent size
        $('#universal_overlay').prop('disabled', true); // TODO change label colour afterwards
        $('#overlay_wrapper').addClass('impossible');
        $('#fade_dur').prop('disabled', true);
        $('#fade_dur_range').prop('disabled', true);
        $('#fade_div').addClass('impossible');
        $('#fades').prop('checked', false);
        $('#fades').prop('disabled', true);
      }else{
        $('#universal_overlay').prop('disabled', false); // Can alter size now
        $('#overlay_wrapper').removeClass('impossible');
        $('#fades').prop('disabled', false);
        if($('#fades').is(':checked')){
          $('#fade_dur').prop('disabled', false);
          $('#fade_dur_range').prop('disabled', false);
          $('#fade_div').removeClass('impossible');
        }
      }
    }else if(opt == 'subtitle_lines'){
      // Expand textarea to fit
      $('#single_line').prop('rows', window.opts._global.subtitle_lines);
    }else if(opt == 'bg_type'){
      if(value == 'full'){
        $('#bg_visible').prop('disabled', false);
        $('#bg_colour').prop('disabled', false);
        $('#bg_opacity').prop('disabled', false);
        $('#bg_opacity_range').prop('disabled', false);
        $('#bg_options').removeClass('impossible');
        $('#bg_width').prop('disabled', false);
        $('#bg_width_text').text('Background width');
        $('#bg_width_range').prop('disabled', false);
      }else if(value == 'tight'){
        $('#bg_visible').prop('disabled', true);
        $('#bg_colour').prop('disabled', false);
        $('#bg_opacity').prop('disabled', false);
        $('#bg_opacity_range').prop('disabled', false);
        $('#bg_options').removeClass('impossible');
        $('#bg_width').prop('disabled', false);
        $('#bg_width_text').text('Text width');
        $('#bg_width_range').prop('disabled', false);
      }else if(value == 'none'){
        $('#bg_visible').prop('disabled', true);
        $('#bg_colour').prop('disabled', true);
        $('#bg_opacity').prop('disabled', true);
        $('#bg_opacity_range').prop('disabled', true);
        $('#bg_width_text').text('Text width');
        $('#bg_width').prop('disabled', false);
        $('#bg_width_range').prop('disabled', false);
        $('#bg_options').addClass('impossible');
      }
    }else if(opt == 'text_align'){
      if(value == 'center' || value == 'justify'){
        $('#h_offset').prop('min', -50);
        $('#h_offset').prop('max', 50);
        $('#h_offset_range').prop('min', -50);
        $('#h_offset_range').prop('max', 50);
        $('#horiz_dir').text('centre');
      }else{
        $('#h_offset').prop('min', 0);
        $('#h_offset').prop('max', 100);
        $('#h_offset_range').prop('min', 0);
        $('#h_offset_range').prop('max', 100);
        $('#horiz_dir').text($('#text_align').val());
        if(window.opts[window.current_style].h_offset < 0){
          window.opts[window.current_style].h_offset = 0;
          clear_style_cache(window.current_style, true);
          set_opt_controls(); // To redraw
        }
      }
    }else if(opt == 'fades'){
      if(value == false){
        $('#fade_dur').prop('disabled', true);
        $('#fade_dur_range').prop('disabled', true);
        $('#fade_div').addClass('impossible');
      }else{
        $('#fade_dur').prop('disabled', false);
        $('#fade_dur_range').prop('disabled', false);
        $('#fade_div').removeClass('impossible');
      }
    }
  }

  function change_opt(evt, slider = false){
    var opt = $(this).attr('id');
    var all = $(this).hasClass('global');
    var style = window.current_style;
    if(all) style = '_global';
    var orig = window.opts[style][opt];
    if($(this).attr('type') == 'number'){
      window.opts[style][opt] = parseFloat($(this).val());
    }else if($(this).attr('type') == 'checkbox'){
      if ($(this).is(':checked')) {
        window.opts[style][opt] = true;
      } else {
        window.opts[style][opt] = false;
      }
    }else{
      window.opts[style][opt] = $(this).val();
    }
    $('#'+opt+'_range').val($(this).val());

    if(orig != window.opts[style][opt]){
      if(!non_size_opt(opt)){
        check_text_width(); // To make it recalculate sizes
        clear_style_cache(style, true);
      }else{
        clear_style_cache(style, false);
      }
      opt_constraints(opt, window.opts[style][opt]);
      display_opts(); // Only refresh on change
      if(!slider){
        prerender(); // Don't slow us down whilst doing slider
      }else{
        $('#'+opt+'_range').on('mouseup', function(e){
          prerender();
          $(this).off('mouseup');
        });
      }
    }
  }

  function escape_filter_option(text){
    return text.replace(/([:'])/g, "\\$1");
  }
  function escape_filter_description(text){
    return text.replace(/([\[\]\\\',;])/g, "\\$1");
  }

  function escape_filtergraph_for_shell(text){
    return text.replace(/\\/g, '\\\\');
  }

  function time_to_hms(time){
    if(!time){
      //if(window.video.duration) return time_to_hms(window.video.duration);
      return '00:00:00,000';
    }
    var s = Math.floor(time);
    var ms = Math.floor ((time - s)*1000);
    var date = new Date(null);
    date.setSeconds(s, ms);
    return date.toISOString().substr(11, 12).replace(/\./, ',');
  }

  function ffmpeg_ready(){
    return !window.ffmpeg_running && window.isWorkerLoaded;
  }

  function ffmpeg_start(){
    window.ffmpeg_running = true;
    $('#ffmpeg_bar').width(0);
    $('#ffmpeg_bar').text('0%');
    $('#ffmpeg_info').show();
    $('#browser_overlay').hide();
    $('#browser_full').hide();
  }

  function ffmpeg_stop(){
    window.ffmpeg_running = false;
    //$('#ffmpeg_info').hide();
    $('#browser_overlay').show();
    $('#browser_full').show();
  }

  function time_to_ass(time){
    if(!time){
      //if(window.video.duration) return time_to_ass(window.video.duration);
      return '0:00:00.00';
    }
    var s = Math.floor(time);
    var hs = Math.floor ((time - s)*100);
    var date = new Date(null);
    date.setSeconds(s, hs*10);
    return date.toISOString().substr(12, 10);
  }

  function export_srt(){
    var file = '';
    close_all_lines();
    for(var i = 0; i < window.timecodes.length; i++){
      var num = i+1;
      file += '' + num + '\n';
      file += time_to_hms(window.timecodes[i].start) + ' --> '+time_to_hms(window.timecodes[i].end) + '\n';
      file += window.timecodes[i].text+'\n\n';

    }
    download(file, "lyrics.srt", 'text/srt');
  }

  function rgb_to_bgr(col, alpha = 1){
    // Can presume 7-digit hex notation
    var r = col[1]+col[2];
    var g = col[3]+col[4];
    var b = col[5]+col[6];
    var a = Math.round(alpha * 255).toString(16);
    return '&H'+a.toUpperCase()+b.toUpperCase()+g.toUpperCase()+r.toUpperCase()+'&';
  }

  function export_ass(){
    // TODO rewrite for styles support â€“ a bit more work
    var wrap = 0;
    var spacer = '';
    close_all_lines();
    if(window.opts.default.bg_type == "full"){
      wrap = 2; // For workaround to enable full-width box
      var char = 'G';
      var num = Math.floor(window.video.videoWidth / (fs_in_px() * 2));
      spacer = '{\\1a&HFF&}{\\bord0}{\\shad0}'+char.repeat(num)+'{\\r}{\\1a&H00&}';
    }
    var res=false;
    var res_text = '';
    if(res) res_text = 'PlayResX: '+window.video.videoWidth+'\nPlayResY: '+window.video.videoHeight+'\n';
    var file = '[Script Info]\nScriptType: V4.00+\n'+res_text+'WrapStyle: '+wrap+'\n\n';
    file += '[V4+ Styles]\nFormat: Name, Fontname, Fontsize, PrimaryColour, BackColour, OutlineColour, Bold, Italic, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV\n';
    file += 'Style: Default,Arial,'+ fs_in_px() +','+rgb_to_bgr(window.opts.default.text_colour)+','+rgb_to_bgr(window.opts.default.bg_colour, window.opts.default.bg_opacity)+','+rgb_to_bgr(window.opts.default.out_colour, 1)+',0,0,4,'+window.opts.default.out_size+','+window.opts.default.shad_off+',2,0,0,0\n\n'; // TODO update with variables
    file += '[Events]\nFormat: Start, End, Style, Text\n';
    for(var i = 0; i < window.timecodes.length; i++){
      var num = i+1;
      var txt = window.timecodes[i].text.replace(/\n/g, '\\n');
      file += 'Dialogue: '+time_to_ass(window.timecodes[i].start) + ',' + time_to_ass(window.timecodes[i].end) + ',Default,'+spacer+txt+spacer+'\n';
    }
    download(file, "lyrics.ass", 'text/ass');
  }

  function playpause(){
    if(window.video.paused) window.video.play();
    else window.video.pause();
  }

  function call_click(id){
    var el = document.getElementById('lyric_text_'+id);
    click_line.call(el, {shiftKey: false}, id);
  }

  function next_lyric(){
    if(window.selected_line == window.ids - 1){
      call_click(window.selected_line);
      return; // To deselect last one
    }
    call_click(+window.selected_line+1);
  }

  function prev_lyric(){
    if(window.selected_line < 0){
      var num = +window.ids - 1;
      call_click(num);
      return;
    }; // No prev ID
    if(window.selected_line == 0){
      call_click(0);
      return;
    }
    var new_id = window.selected_line-1;
    call_click(new_id);
  }


  function download(data, filename, type) {
    var file = new Blob([data], {type: type});
    if (window.navigator.msSaveOrOpenBlob) // IE10+
    window.navigator.msSaveOrOpenBlob(file, filename);
    else { // Others
      var a = document.createElement("a"),
      url = URL.createObjectURL(file);
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      setTimeout(function() {
        document.body.removeChild(a);
        window.URL.revokeObjectURL(url);
      }, 0);
    }
  }

  function process_lyrics(){
    var lyrics = $.trim($('#lyrics').val());
    $('#lyrics').val('');
    $('#lyrics').blur();
    if(lyrics === '') return;
    //window.timecodes = []; // Reset everything
    //var lines = lyrics.match(/[^\r\n]+/g);
    var splitter = new RegExp('(?:[^\\n\\r]+[\\n\\r]?){1,'+window.opts._global.subtitle_lines+'}', 'g');
    var lines = lyrics.match(splitter);
    lines = lines.filter(a => {if(a === '') return false; return true;}); // Should (I hope!) allow for multi-line splitting
    var inside = '';
    lines.forEach(function(line){
      line = line.trim();
      inside += '<div id="lyric_line_'+window.ids+'"></div><div class="line_text" id="lyric_text_'+window.ids+'">'+line+'</div>' // from <span id="lyric_start_'+ln+'">0</span> seconds to <span id="lyric_end_'+ln+'">0</span> seconds</div>';
      window.ids++;
    });
    existing = $('#lyrics_array').html();
    $('#lyrics_array').html(existing+inside);
    rescan_sub_lines();
    //$('.line_text').on('click', click_line);
    var evt = new MouseEvent('click', {view: window, bubbles: true, cancelable: true});
    $('#place_tab')[0].dispatchEvent(evt);
  }

  function rescan_sub_lines(){
    var min = 1;
    /*$('.line_text').each(function(i){
      var n = $(this).text().split(/[\n\r]/).length;
      if(n > min) min = n;
    });*/
    window.timecodes.forEach(function(tc){
      var n = tc.text.split(/[\n\r]/).length;
      if(n > min) min = n;
    })
    $('#subtitle_lines_range').prop('min', min);
    $('#subtitle_lines').prop('min', min);
    if(window.opts._global.subtitle_lines < min){
      window.opts._global.subtitle_lines = min;
      window.cached_canvases = {};
      preview_canvas();
      set_opt_controls();
    }
  }

  function split_selected(){
    var split = $('#lyric_text_'+window.selected_line).text().split('\n');
    //console.log(split);
    var results = [];
    for(let i = 0; i < window.ids; i++){
      if(i == window.selected_line){
        split.forEach(function(l){
          results.push(l);
        });
      }else{
        results.push($('#lyric_text_'+i).text());
      }
    }
    window.ids = results.length;
    var h = '';
    results.forEach(function(line, ind){
      var select = "";
      if(ind == window.selected_line) select=" selected";
      h += '<div id="lyric_line_'+ind+'"></div><div class="line_text'+select+'" id="lyric_text_'+ind+'">'+line+'</div>';
    });
    //console.log(h);
    $('#lyrics_array').html(h);
    //$('.line_text').on('click', click_line);
    var c_i = current_lyric();
    window.timecodes[c_i].text = split[0];
    $('#text_'+c_i).text(split[0]);
    $('#join_lyric').show();
    $('#split_lyric').hide();
    update_lyrics();
    //update_list?
  }

  function join_selected(){
    var results = [];
    for(let i = 0; i < window.ids; i++){
      var text = $('#lyric_text_'+i).text();
      //console.log(text, i);
      if(i == window.selected_line){
        i++;
        text = text + '\n' + $('#lyric_text_'+i).text();
        var c_i = current_lyric();
        window.timecodes[c_i].text = text;
        $('#text_'+c_i).text(split[0]);
      }
      results.push(text);
    }
    window.ids = results.length;
    var h = '';
    results.forEach(function(line, ind){
      var select = "";
      if(ind == window.selected_line) select=" selected";
      h += '<div id="lyric_line_'+ind+'"></div><div class="line_text'+select+'" id="lyric_text_'+ind+'">'+line+'</div>';
    });
    $('#lyrics_array').html(h);
    //$('.line_text').on('click', click_line);
    //update_list?
    $('#split_lyric').show();
    if(+window.selected_line + 1 >= window.ids) $('#join_lyric').hide();
    // Make sure you adjust subtitle min range
    update_lyrics();
  }

  function add_line(){
    //var h = $('#lyrics_array').html();
    var single = document.getElementById('single_line');
    var line = single.value.trim();
    single.value = '';
    //$('#single_line').blur();
    if(line === '') return;
    //onsole.log(line);
    var h = '<div id="lyric_line_'+window.ids+'"></div><div class="line_text" id="lyric_text_'+window.ids+'">'+line+'</div>';
    window.ids++;
    $('#lyrics_array').append(h);
    //$('#lyrics_array').html(h);
    rescan_sub_lines();
    //$('.line_text').on('click', click_line);
    // Auto-click line
    var id = window.ids - 1;
    evt = {shiftKey: false};
    element = document.getElementById('lyric_text_'+id);
    click_line.call(element, evt, id);
    //$('#lyric_text_'+id).trigger('mousedown');
  }

  function lyric_index_at_time(time){
    var lyric_line = window.timecodes.findIndex(function(line, i){
      if(!('start' in line)) return false;
      if(line.start <= time){
        if(!('end' in line)) return true; // Presume so as it's not finished yet!
        if(line.end > time) return true;
        return false;
      }
    });
    return lyric_line;
  }

  function lyric_at_time(time){
    var l = lyric_index_at_time(time);
    if(l != -1) return window.timecodes[l];
    return false;
  }

  function timeupdate(){
    var time = timecode();
    if(time == window.last_timecode) return; // No duplication
    window.last_timecode = time;
    sync_lyrics();
  }

  function sync_lyrics(){
    //console.log('sl', window.timecodes);
    if(window.timecodes.length < 1){
      //$('#preview').text('');
      window.preview_line = { start: 0, end: 0, text: ''};
      preview_canvas();
      //console.log('slearly', window.timecodes);
      return;
    }

    // Presume if not that we have at least some timecodes to work with!
    var lyric_line = lyric_at_time(timecode());
    if(lyric_line){
      var style = lyric_line.style || 'default';
      if(style != window.current_style){
        window.current_style = style;
        set_opt_controls();
      }
      //$('#preview').text(lyric_line.text);
      window.preview_line = lyric_line;
      preview_canvas();
    }else{
      // No lyrics here
      //$('#preview').text('');
      window.preview_line = {start: 0, end: 0, text: ''};
      preview_canvas();
    }
    //console.log('sle', window.timecodes);
  }

  function timecode(){
    return document.getElementById('vid').currentTime;
  }

  function deselect(){
    $('.selected').removeClass('selected');
    window.selected_line = -1;
    $('#split_lyric').hide();
    $('#join_lyric').hide();
    $('#deselect_lyric').hide();
  }

  function get_list_row(index){
    var end_time = '(no end yet)';
    if(window.timecodes[index].end) end_time = time_to_hms(window.timecodes[index].end);
    return '<tr id="row_'+index+'"><td><span class="time" id="start_'+index+'">'+time_to_hms(window.timecodes[index].start)+'</span> - <span class="time" id="end_'+index+'">'+end_time+'</span>:</td><td width="100%"><div class="lyrics_text" id="text_'+index+'">'+window.timecodes[index].text+'</div></td><td>Style: <select class="lyrics_style" id="style_'+index+'">'+style_options(window.timecodes[index].style)+'</select></td><td><span class="delete" id="delete_'+index+'">Delete this entry</span></td></tr>'
  }

  function push_lyric(text, t){
    var l = {};
    l.start = t;
    l.text = text;
    l.style = window.current_style;
    var len = window.timecodes.length;
    window.timecodes.push(l);
    if(len > 0 && l.start > window.timecodes[len - 1].start){
      // Normal situation where you're simply appending
      if(window.timecodes[len - 1].end > l.start){
        // cut it back to fit
        tc_set_end(len - 1, l.start);
      }
      $('#list tr:last').after(get_list_row(len));
    }else{
      check_overlap(len);
      update_list();
    }
    return t;
  }

  function current_lyric(){
    // Find the currently selected (i.e. unfinished) lyric
    var i = window.timecodes.findIndex(tc => !tc.end);
    return i;
  }

  function end_lyric(t){
    var i = current_lyric(); // Find the unfinished timecode
    if(i == -1) return;
    tc_set_end(i, t);
    deselect();
    check_overlap(i);
    sync_lyrics();
    //update_list?
  }

  function update_lyrics(){
    rescan_sub_lines();
    sync_lyrics();
  }

  function update_list(){
    // Should now only need to call this if the _structure_ of the array has changed
    // (i.e. elements added, deleted or reordered)
    if(window.timecodes.length == window.prev_list_length) return;
    window.prev_list_length = window.timecodes.length;
    var html = '<table>';
    rescan_sub_lines();
    window.timecodes.sort(function(a,b){return a.start - b.start;});
    window.timecodes.forEach(function(line, index){
      var style = 'default';
      if(line.style) style = line.style;
      html += get_list_row(index);
    });
    html += '</table>';
    $('#list').html(html);
    sync_lyrics();
  }

  function click_time(evt){
    if(evt.shiftKey){
      if(evt.altKey){
        shunt_time($(this).attr('id'));
      }else{
        set_time($(this).attr('id'));
      }
    }else{
      goto_time($(this).attr('id'));
    }
  }

  function opt(line, opt){
    if(line.style) return window.opts[line.style][opt];
    return window.opts.default[opt];
  }

  function edit_lyric(evt){
    if(evt.shiftKey) return;
    //$(this).off('click'); // To stop it refiring when you do stuff with the edit box
    if($(this).html().match(/<textarea /)) return; // Don't bother if you've already got a textbox editing here
    var id = $(this).attr('id').substring(5);
    //console.log(this);
    $(this).html('<textarea style="white-space: prewrap; width: 100%;" rows="'+window.opts._global.subtitle_lines+'" id="edit_'+id+'">'+window.timecodes[id].text+'</textarea>');
    $('#edit_'+id).on('change blur', function() {
      if(window.timecodes[id].text != $(this).val()){
        add_undo();
        window.timecodes[id].text = $(this).val();
      }
      $(this).parent().text(window.timecodes[id].text);
      update_lyrics();
      //update_list?
    });
    $('#edit_'+id).keydown(function(e){
      if(e.which === 13 && count_occ($(this).val(), '\n') >= window.opts._global.subtitle_lines - 1){
        if(window.timecodes[id].text != $(this).val()){
          add_undo();
          window.timecodes[id].text = $(this).val();
        }
        $(this).parent().text(window.timecodes[id].text);
        update_lyrics();
        //update_list?
      }
    });

    $('#edit_'+id).focus().val($('#edit_'+id).val());
  }

  function change_lyric_style(){
    var id = $(this).attr('id').substring(6);
    add_undo();
    if(window.selected_line != -1 && current_lyric() == id){
      window.timecodes[id].style = $(this).val();
      clear_cache(window.timecodes[id]);
      set_style($(this).val()); // This is the current one
    }else{
      window.timecodes[id].style = $(this).val();
      clear_cache(window.timecodes[id]);
      //size_canvas(); // In case of changing height
    }
  }

  function edit_line(id, that){
    //$(this).off('click'); // To stop it refiring when you do stuff with the edit box
    if(that.html().match(/<textarea /)) return; // Don't bother if you've already got a textbox editing here
    var width = that.width();
    that.html('<textarea style="white-space: prewrap; width: '+width+'px;" rows="'+window.opts._global.subtitle_lines+'" id="edit_line_'+id+'">'+that.text()+'</textarea>');
    $('#edit_line_'+id).on('change blur', function() {
      $(this).parent().text($(this).val());
      if(window.selected_line == id){
        var c_i = current_lyric();
        window.timecodes[c_i].text = $(this).val();
        $('#text_'+c_i).val(window.timecodes[c_i].text);
      }
    });
    $('#edit_line_'+id).keydown(function(e){
      if(e.which === 13 && count_occ($(this).val(), '\n') >= window.opts._global.subtitle_lines - 1){
        $(this).parent().text($(this).val());
        if(window.selected_line == id){
          var c_i = current_lyric();
          window.timecodes[c_i].text = $(this).val();
          $('#text_'+c_i).val(window.timecodes[c_i].text);
        }
      }
    });
    $('#edit_line_'+id).click(function(e){
      e.stopPropagation();
    });

    $('#edit_line_'+id).focus().val($('#edit_line_'+id).val());
  }

  function click_line(evt, id = ''){
    //console.log(window.selected_line);
    var time = timecode();
    if(id === '') id = $(this).attr('id').substring(11);
    if(evt.shiftKey){
      edit_line(id, $(this));
      evt.preventDefault();
      return;
    }
    if(window.selected_line == id){
      //Deselect this line
      if(time >= window.timecodes[current_lyric()].start){
        // Normal operation â€“ end a lyric we started, even if it is 0-length (in which case it will automatically be deleted)
        end_lyric(time);
      }else{
        // We've jumped back before the start of the lyric, so maybe we want it to start earlier?
        add_undo();
        window.timecodes[current_lyric()].start = time;
        check_overlap(current_lyric());
        sync_lyrics();
        //update_list? // done within check_overlap now
      }

      // Either way, we've done our job
      return;
    }
    if(window.selected_line != -1 ){
      // There was a previous line, so deselect them and set their end_time
      //$('#lyric_end_'+window.selected_line).text(timecode());
      end_lyric(time);
    }
    //click_line_text(this.textContent, time);
    //$('#lyric_start_'+id).text(timecode());
    push_lyric(this.textContent, time);
    check_text_width();
    $(this).addClass('selected');
    window.selected_line = id;
    if(this.textContent.match(/\n/)) $('#split_lyric').show();
    if(+window.selected_line + 1 < window.ids) $('#join_lyric').show();
    $('#deselect_lyric').show();
  }

  function save_subs(){
    var tc = get_json();
    download(tc, "lyrics.json", "application/json");
  }

  function get_json(){
    var tc = {
      opts: window.opts,
      timecodes: window.timecodes
    }
    return JSON.stringify(tc);
  }

  function restore_subs(struct){

  }

  function convert_fields_to_percentage(style){
    var to_convert = [];
    var exclude = ['font_size', 'video_size'];
    window.percentage_fields.forEach(function(f){
      if(exclude.includes(f)) return;
      if(style[f]){
        if(f[0] == 'h' || f.match('width')){
          style[f] = style[f] / window.video.videoWidth * 100;
          style[f] = parseFloat(style[f].toFixed(1));
        }else{
          style[f] = style[f] / window.video.videoHeight * 100;
          style[f] = parseFloat(style[f].toFixed(1));
        }
      }
    });
    return style;
  }

  function load_subs(file){
    window.cached_canvases = {};
    var f = JSON.parse(file);
    var convert_fields = false;
    if(f.length > 0){
      //console.log('old');
      // Backwards-compatibility: pure subtitles
      window.timecodes = f;
    }else{
      if(!f._percentages) convert_fields = true;
      // Contains style information //
      if(f.opts._global){
        //console.log('global');
        // Up-to-date style info
        window.opts = $.extend(true, window.opts, f.opts);
        //console.log(window.opts);
        // TODO make this go through and import relevant styles, AND TODO check that they don't mind overwriting
      }else{
        // Need to convert
        if(convert_fields){
          f.opts = convert_fields_to_percentage(f.opts);
        }
        Object.keys(window.opts._global).forEach(function(o){
          if(f.opts[o]) window.opts._global[o] = get_opt(o, f.opts[o]);
        });
        Object.keys(window.opts.default).forEach(function(o){
          if(f.opts[o]) window.opts.default[o] = get_opt(o, f.opts[o]);
        });
      }
      if(typeof window.opts._global.bg_visible == 'string') window.opts._global.bg_visible = (window.opts._global.bg_visible == 'true');
      window.timecodes = f.timecodes;
    }
    prerender();
    display_opts();
    set_opt_controls();
    update_list();
    if(current_lyric() != -1) $('#deselect_lyric').show();
    //console.log(window.opts);
    //console.log(overlay_height());
  }

  function get_opt(o, val){
    if($('#'+o).attr('type') == 'number'){
      if(typeof val == 'string') return parseFloat(val);
    }else if($('#'+o).attr('type') == 'checkbox'){
      if(typeof val == 'string') return (val == 'true');
    }
    return val;
  }

  function storageAvailable(type) {
    var storage;
    try {
      storage = window[type];
      var x = '__storage_test__';
      storage.setItem(x, x);
      storage.removeItem(x);
      return true;
    }
    catch(e) {
      return e instanceof DOMException && (
        // everything except Firefox
        e.code === 22 ||
        // Firefox
        e.code === 1014 ||
        // test name field too, because code might not be present
        // everything except Firefox
        e.name === 'QuotaExceededError' ||
        // Firefox
        e.name === 'NS_ERROR_DOM_QUOTA_REACHED') &&
        // acknowledge QuotaExceededError only if there's something already stored
        (storage && storage.length !== 0);
      }
    }

    function save_opts(){
      localStorage.setItem('format_multi', JSON.stringify(window.opts));
      localStorage.setItem('format_saved', true);
    }

    function save_codec(){
      localStorage.setItem('saved_codec', $('#codec').val());
      localStorage.setItem('saved_rate', $('#rate').val());
    }

    function load_codec(){
      var codec = localStorage.getItem('saved_codec');
      if(codec) $('#codec').val(codec);
      var rate = localStorage.getItem('saved_rate');
      if(rate) $('#rate').val(rate);
    }

    function init_opts(){
      window.opts = {
        _percentages: true,
        default: {
          text_colour: "#ffffff",
          bg_colour: "grey",
          font_size: 5, // percent of screen height
          font: 'sans-serif',
          line_spacing: 1,
          v_margin: 1,
          v_offset: 0,
          h_offset: 0,
          h_margin: 1,
          bg_type: "full", // possibilities: 'full' border, 'tight' box, 'none'
          bg_border: 0,
          bg_opacity: 0.6,
          bg_width: 100,
          bg_type: 'full',
          out_colour: "#000000",
          out_size: 0,
          shad_colour: "#000000",
          shad_off: 3,
          shad_op: 0.7,
          shad_blur: 30,
          text_align: 'center',
          v_align: 'middle',
          bold: false,
          italic: false,
          wrap: true
        },
        _global: {
          subtitle_lines: 1,
          video_size: 50,
          universal_overlay: true, // i.e. resize the overlay to the size of the tallest font
          bg_visible: false,
          min_height: true,
          fades: false,
          fade_dur: 1
        }
      };
    }

    function load_opts(){
      init_opts();
      window.cached_canvases = {};
      if(!localStorage.getItem('format_saved')){
        display_opts();
        set_opt_controls();
        return;
      }
      if(localStorage.getItem('format_multi')){
        // New style formatting using JSON
        var styles = JSON.parse(localStorage.getItem('format_multi'));
        // Do it carefully so we don't lose any new things added
        Object.keys(styles).forEach(function(s){
          if(s in window.opts){
            $.extend(true, window.opts[s], styles[s]);
          }else{
            window.opts[s] = $.extend(true, {}, window.opts.default, styles[s]);
          }
        })
      }else{
        // Old default formatting
        for(setting in window.opts){
          var temp = localStorage.getItem('format_options_'+setting);
          if(temp) window.opts.default[setting] = temp; // For backwards compatibility (really I should have been using JSON, but hey...)
        }
      }
      display_opts();
      set_opt_controls();
    }

    function wipe_opts(){
      if(!confirm('Are you sure you want to reset formatting?')) return;
      localStorage.removeItem('format_saved');
      localStorage.removeItem('format_multi');
      load_opts();
      display_opts();
      set_opt_controls();
    }

    function canvas_to_blob_promise(canvas, type = window.img_type){
      return new Promise(function(resolve, reject){
        var c = canvas.toBlob(function(blob){
          if(blob.type == 'image/'+type){
            resolve(blob);
          }else if(type == 'tiff'){ // Chrome since it can't do this
            window.img_type = 'webp';
            var c = canvas.toBlob(function(blob){
              resolve(blob)
            }, 'image/'+window.img_type);
          }else{
            console.log('unable to produce correct image type');
            resolve(blob); // Do it anyway, but complain
          }
        }, 'image/'+type);
      });
    }

    function canvasTextHeight(style) {

      const canvas = window.test_canvas;
      const ctx = canvas.getContext('2d');
      const text = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
      ctx.font = get_font(style);
      const textMetrics = ctx.measureText(text);

      var ascent = textMetrics.actualBoundingBoxAscent;
      var descent = textMetrics.actualBoundingBoxDescent;

      var height = ascent + descent;
      var result = {
        height: height,
        ascent: ascent,
        descent: descent
      }
      return result;
    }

    function list_styles(in_use = 'all'){
      return Object.keys(window.opts).filter(function(s){
        if(s[0] == '_') return false; // filter out globals
        if(in_use == 'all') return true;
        return window.timecodes.some((t) => {
          if(t.style) return t.style == s;
          return s == 'default'; // For if no style is set
        });
      });
    }


    function style_options(style){
      var html = '';
      if(!style) style = 'default';
      list_styles('all').forEach(function(s){
        var selected = '';
        if(s === style) selected = ' selected'
        html += '<option value="'+s+'" '+selected+'>'+s+'</option>'; // TODO make sure style names on entry are escaped
      })
      return html;
    }

    function tallest_height(){
      return get_max_height(-1);
      /*var tallest = 0;
      list_styles('in use').forEach(function(s){
        var height = canvasTextHeight(s).height  * window.opts[s].line_spacing * 1.2 * window.opts._global.subtitle_lines + proportion('height', window.opts[s].v_margin) * 2;
        if(height > tallest) tallest = height;
      })

      return tallest;*/
    }

    function non_size_opt(o){
      if(o.endsWith('_opacity')) return true;
      if(o.endsWith('_op')) return true;
      if(o.endsWith('_colour')) return true;
      if(o.endsWith('_type')) return true;
      if(o.endsWith('_blur')) return true;
      return false;
    }

    function all_fonts_same_size(){
      var same = true;
      list_styles('in use').forEach(function(s){
        if(Number.parseInt(window.opts[s].font_size) != Number.parseInt(window.opts.default.font_size)) same = false;
      });
      return same;
    }

    function get_max_width(text, style = 'default'){
      const canvas = window.test_canvas;
      const ctx = canvas.getContext('2d');
      var max = 0;
      text.forEach(function(line){
        ctx.font = get_font(style);
        const textMetrics = ctx.measureText(line);
        var width = textMetrics.actualBoundingBoxLeft + textMetrics.actualBoundingBoxRight;
        var tw = Number.parseInt(width.toFixed(1));
        if(tw > max) max = tw;
      });
      return max;
    }

    function get_sub_height(sub){
      if(sub.height) return sub.height; // Save cached values
      const canvas = window.test_canvas;
      const ctx = canvas.getContext('2d');
      ctx.font = get_font(s);
      var s = sub.style || 'default';
      var lines = sub.text.split(/[\r\n]/);
      if(window.opts[s].wrap){
        if(!sub.wrap) sub.wrap = wrap_text(lines, s);
        lines = sub.wrap.text;
      }
      var h = 0;
      lines.forEach(function(l){
          const textMetrics = ctx.measureText(l);
          var height = textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent; // TODO check it works!
          if (height > h){
            h = height;
          }
      });
      h = h * window.opts[s].line_spacing * 1.2 * lines.length + proportion('height', window.opts[s].v_margin) * 2;
      //console.log(h);
      sub.height = h;
      return h;
    }

    function get_max_height(style){
      var styles = [];
      if(style == -1) styles = list_styles('in use');
      else styles = [style];
      var mh = 0;
      styles.forEach(function(s){
        var sh = 0;
        window.timecodes.filter(tc => tc.style == s || s == 'default').forEach(function(tc){
          var h = get_sub_height(tc);
          if(h > sh) sh = h;
        });
        if(sh > mh) mh = sh;
      });
      return mh;
    }

    function proportion(dim, num){
      if(dim == 'width') return window.video.videoWidth / 100 * num;
      else return window.video.videoHeight / 100 * num;
    }

    /*function proportional_width(style = 'default'){
      var prop = window.opts[style].bg_width || window.opts.default.bg_width;
      var actual_width = window.video.videoWidth / 100 * prop;
      return parseInt(actual_width.toFixed(0));
    }*/

    function text_width(text, style = 'default'){
      const canvas = window.test_canvas;
      const ctx = canvas.getContext('2d');
      ctx.font = get_font(style);
      const textMetrics = ctx.measureText(text);
      var width = textMetrics.actualBoundingBoxLeft + textMetrics.actualBoundingBoxRight;
      return textMetrics.width;
    }

    function cache_size(tc){
      var mw = 0;
      var h = 0;
      tc.text.split(/[\n\r]/).forEach(function(line){
        var style = tc.style || 'defia'
      });
    }

    function check_text_width(){
      var biggest = 0;
      var ratios = Object.fromEntries(list_styles('in use').map(function(s){
        return [s, 0];
      }));
      window.timecodes.forEach(function(sub){
        var style = sub.style || 'default';
        if(sub.width){
          var ratio = sub.width / Number.parseInt(proportion('width', window.opts[style].bg_width));
          if(ratio > biggest) biggest = ratio;
          if(ratio > ratios[style]) ratios[style] = ratio;
          return;
        }else{
          sub.text.split(/[\n\r]/).forEach(function(line){
            var tw = Number.parseInt(text_width(line, style).toFixed(1)) + proportion('width', window.opts[style].h_margin) * 2;
            if(!sub.width || tw > sub.width) sub.width = tw;
            var vw = Number.parseInt(proportion('width', window.opts[style].bg_width));
            var ratio = tw / vw;
            if(ratio > ratios[style]) ratios[style] = ratio; // Should now also include larger ones!
            if(ratio > biggest) biggest = ratio;
          });
        }
      });
      if(biggest <= 1){
        if($('#size_warning').html() != '') $('#size_warning').html('');
        $('#fit_width').show();
        $('.fit_to_screen').hide();
      }else{
        if($('#size_warning').html() == '') $('#size_warning').html('Warning: font too large, some subtitles won\'t fit on screen!<button class="w3-btn w3-blue fit_to_screen" type="button">Fix this</button>');
        $('.fit_to_screen').show();
        $('.fit_to_screen').off('click').on('click', function(){
          fit_text_to_width(ratios, biggest, false);
          $('.fit_to_screen').hide();
        });
        $('#fit_width').hide();
        return false;
      }
      $('#fit_width').off('click').on('click', function(){
        fit_text_to_width(ratios, biggest, true);
        $('#fit_width').hide();
        $('.fit_to_screen').hide();
      });
      return true;
    }

    function fit_text_to_width(ratios, biggest, up_too = false){
      Object.keys(ratios).forEach(function(s){
        var orig_size = o;
        if(all_fonts_same_size()){
          // Presume they want to preserve everything the same size;
          if(biggest > 1 || up_too) window.opts[s].font_size = window.opts[s].font_size / biggest - 0.1;
        }else{
          if(ratios[s] > 1 || up_too) window.opts[s].font_size = window.opts[s].font_size / ratios[s] - 0.1;
        }
        window.opts[s].font_size = Number.parseFloat(window.opts[s].font_size.toFixed(1));
        if(o != window.opts[s].font_size) clear_style_cache(s, true);
      });
      $('#size_warning').html('');
      set_opt_controls();
      preview_canvas();
      if(!window.video.playing) prerender();
    }

    function fs_in_px(style = window.current_style, raw_size = false){
      var font_size = 0;
      if(raw_size){
        font_size = style;
      } else {
        font_size = window.opts[style].font_size;
      }
      if(window.video.videoWidth){
        return (font_size / 100) * window.video.videoWidth // / window.devicePixelRatio;
      }
      return (font_size / 100) * 1920 // / window.devicePixelRatio; // presume HD, optimistically
    }

    function isEven(n) {
      return n % 2 == 0;
    }

    function overlay_height(style = window.current_style){
      var font_height = 0;
      if(window.opts._global.universal_overlay){
        font_height = get_max_height(-1);
      }else{
        font_height = get_max_height(style); //canvasTextHeight(style).height * window.opts[style].line_spacing * 1.2 * window.opts._global.subtitle_lines + proportion('height', window.opts[style].v_margin) * 2;
      }
      /*if(!isEven(font_height)){
      return font_height+1;
    }*/
    return font_height;
  }

  function get_font(s = 'default'){
    var style = '';
    var weight = '';
    if(window.opts[s].italic) style = 'italic ';
    if(window.opts[s].bold) weight = 'bold ';
    return style+weight+fs_in_px(s)+'px '+window.opts[s].font;
  }

  function min_height(){
    var def_height = overlay_height('default')+proportion('height', window.opts.default.v_offset);
    list_styles('in use').forEach(function(s){
      if(!window.timecodes.some(t => t.style == s || s == 'default')) return; // Discount styles not actually included in lyrics
      var h = overlay_height(s)+proportion('height', window.opts[s].v_offset);
      if(h > def_height) def_height = h;
    });
    return def_height;
  }

  function canvas_height(){
    if(window.opts._global.min_height){
      return min_height();
    }else{
      return document.getElementById('vid').videoHeight;
    }
  }

  function video_placeholder(){
    // Draw a placeholder image
    var canvas = $('#placeholder')[0];
    var ctx = canvas.getContext('2d');

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.globalAlpha = 1;
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.font = 'bold '+fs_in_px(5, true)+'px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = 'white';
    ctx.fillText('[Video will go here]', canvas.width/2, canvas.height/2);
  }

  function wrap_text(text, style = 'default'){
    var text_lines = [];
    var last_lines = [];
    var ret_obj = {text: [''], last_lines: []};
    var max_w = proportion('width', window.opts[style].bg_width) - proportion('width', window.opts[style].h_margin) * 2;
    if(text.length == 1 && text[0] == '') return ret_obj;
    text.forEach(function(line){
      var current_width = 0;
      var current_line = '';
      text_lines.push(line); // Single words don't get wrapped
      if(line.split(' ').length > 1) line.split(' ').forEach(function(word){
        if(current_line.length > 0) current_line += ' ';
        var new_width = text_width(current_line+word, style);
        //console.log('length of',current_line+' '+word,new_width,max_w);
        if(new_width < max_w){
          // add to current line
          current_line += word;
          current_width = new_width;
          text_lines[text_lines.length - 1] = current_line; // Ensures we don't lose last line
        }else{
          // end current line and make new one
          current_line = word;
          current_width = text_width(word);
          text_lines.push(current_line); // Start new line
        }
      });
      last_lines.push(text_lines.length - 1); // show that this is a last line
    });
    //console.log(text_lines);
    ret_obj = {
      text: text_lines,
      last_lines: last_lines
    };
    return ret_obj;
  }

  function justified_text(params){
    // Presumes it's already been wrapped, since it will have been!
    // TODO could add ability to deal with italics etc. â€“ or add this in text_width? Or elsewhere?
    // Could generalise this function for all text, to handle escaped style preferences etc.
    // Don't suppose I want to handle leading...??!??!
    var words = params.text.split(' ');
    var style = params.style || 'default';
    var x = params.x;
    var y = params.y;
    var width = params.width;
    var ctx = params.ctx; // Presumes it's all set up with relevant formatting codes etc.
    var type = params.type; // 'fill' or 'stroke'
    var threshold = params.threshold || 0;
    threshold = width * threshold;

    // First, get width without spaces
    var running_width = 0;
    words.forEach(function(word){
      running_width += text_width(word, style);
    });

    if(running_width < threshold){ // Too narrow to justify, so just draw
      if(type == 'fill') ctx.fillText(params.text, x, y);
      if(type == 'stroke') ctx.strokeText(params.text, x, y);
      return;
    }

    // Then, get gap
    var gap = 0;
    if(words.length > 1) gap = (width - running_width) / (words.length - 1); // Note that if this is negative, words will overlap, which is probs ok
    var x_off = 0;

    //console.log(words,gap,x,y);

    // Now draw it!
    words.forEach(function(word){
      if(type == 'fill') ctx.fillText(word, x+x_off, y);
      if(type == 'stroke') ctx.strokeText(word, x+x_off, y);
      x_off += text_width(word, style) + gap;
    });

  }

  function max_lines(){
    var max = window.opts._global.subtitle_lines;
    window.timecodes.forEach(function(tc){
      var style = tc.style || 'default';
      var text = tc.text.split(/[\r\n]/);
      if(window.opts[style].wrap){
        if(!tc.wrap) tc.wrap =  wrap_text(text, style);
        text = tc.wrap.text;
      }
      if(text.length > max) max = text.length;
    });
    return max;
  }

  function draw_subtitle(line, end_canvas, blank = false){
    var end_ctx = null;
    if(end_canvas) end_ctx = end_canvas.getContext('2d');

      var s = line.style || 'default';
      var cc = get_cached_canvas(line, s);
      if(cc && cc.canvas && cc.canvas.width == window.video.videoWidth){ // Redo when we reload
        if(end_canvas){
          end_canvas.width = window.video.videoWidth;
          end_canvas.height = canvas_height(); //cc.canvas.height;
          //console.log('ec', end_canvas.width, end_canvas.height);
          var y_off = end_canvas.height - cc.canvas.height;
          if(y_off < 0){
            console.log('negative!');
          }
          else if(y_off > 0) console.log('postive!');
          //console.log(cc.canvas.width);
          end_ctx.clearRect(0, 0, end_canvas.width, end_canvas.height);
          //console.log(end_ctx,cc.canvas);
          end_ctx.drawImage(cc.canvas, 0, y_off);
        }
        //console.log(cc);
        if(cc.users.indexOf(line) == -1) cc.users.push(line);
        return;
      }

    // Save for future reuse
    var canvas = document.createElement('canvas');
    var ctx = canvas.getContext('2d');

    var height = overlay_height(s) + proportion('height', opt(line, 'v_offset'));
    var lines = max_lines(); // allowing us to change it for wrapping
    //console.log(overlay_height(s), height);
    var wrap = opt(line, 'wrap');
    varÂ last_lines = [];

    canvas.height = canvas_height();
    var y_orig = canvas.height - height;
    if(window.opts._global.min_height && !isEven(canvas.height)){
      canvas.height++;
      y_orig++; // so it pushes it down slightly
    }

    var txt = line.text.split(/[\r\n]/); // For multi-line text

    //console.log(window.timecodes);
    if(wrap){
      if(!line.wrap) line.wrap = wrap_text(txt,s);
      txt = line.wrap.text;
      //console.log(line, line.wrap, txt);
      //console.log(obj, txt);
      last_lines = line.wrap.last_lines;
    }
    //console.log(line.wrap,line.height,line.width);
    //console.log(wrap_text(txt, s));
    var spare_lines = 0;
    if(lines > txt.length) spare_lines = lines - txt.length; // To keep things padded
    var resultant_height = overlay_height(s) - (proportion('height', opt(line,'v_margin')) * 2);
    var unit = resultant_height / (txt.length + spare_lines); // i.e. full height for whatever

    canvas.width = window.video.videoWidth;
    if(canvas.height == 0 || canvas.width == 0) return; // Something wrong eg. video not loaded yet
    ctx.clearRect(0, 0, canvas.width, canvas.height);


    if(window.is_audio) video_placeholder();

    //console.log('drawing');
    if(end_canvas){
      if(end_canvas.width != canvas.width) end_canvas.width = canvas.width;
      if(end_canvas.height != canvas.height) end_canvas.height = canvas.height;
      end_ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    if(line.text == '' && !window.opts._global.bg_visible) return; // No need to do any drawing
    // Draw background
    //console.log('drawing text fresh;');

    var translate = 0;
    if(opt(line, 'v_align') == 'middle'){
      translate += spare_lines * unit / 2;
    }else if(opt(line, 'v_align') == 'bottom'){
      translate += spare_lines * unit;
    }
    var bg_trans = 0;
    var bg_height = overlay_height(s);
    var text_width = 0;
    var bg_width = canvas.width;
    var bg_start = 0;
    var h_off = proportion('width', opt(line, 'h_offset'));

    if(opt(line,'bg_type') == 'full'){
      bg_width = proportion('width', opt(line, 'bg_width'));
      text_width = bg_width - proportion('width', opt(line, 'h_margin')) * 2;
      bg_start = (canvas.width - bg_width) / 2 + h_off;
      if(opt(line, 'text_align') == 'left') bg_start = h_off;
      if(opt(line, 'text_align') == 'right') bg_start = canvas.width - bg_width - h_off;
    }else{
      if(!line.width) line.width = get_max_width(txt, s);
      text_width = line.width;
      bg_width = proportion('width', opt(line, 'h_margin')) * 2 + text_width;
      var bg_margin = (canvas.width - bg_width) / 2 + h_off;
      bg_trans = translate;
      bg_height = get_sub_height(line); // TODO handle universal_overlay!
      //bg_height = unit * txt.length; // TODO I think!!
      bg_start = bg_margin;
      if(opt(line, 'text_align') == 'left') bg_start = h_off;
      if(opt(line, 'text_align') == 'right') bg_start = canvas.width - bg_width - h_off;
    }

    if(opt(line,'bg_type') != 'none'){
      ctx.globalAlpha = opt(line, 'bg_opacity');
      ctx.fillStyle = opt(line, 'bg_colour');
      ctx.fillRect(bg_start, y_orig+bg_trans, bg_width, bg_height);
      ctx.globalAlpha = 1;
    }

    if(blank) return;

    translate += proportion('height', opt(line,'v_margin'));

    // Draw text
    ctx.font = get_font(s);

    //txt.forEach(function(t, i){

    var align = opt(line, 'text_align');


    //ctx.fillStyle = window.opts.text_colour;
    //ctx.fillText("asdas",0,0);
    ctx.textBaseline = 'middle';
    ctx.save();
    ctx.fillStyle = opt(line, 'text_colour');
    if(opt(line,'shad_off') > 0 || opt(line, 'shad_blur') > 0){
      ctx.shadowOffsetX = opt(line, 'shad_off');
      ctx.shadowOffsetY = opt(line, 'shad_off');
      ctx.shadowColor = "rgba(" + opt(line, 'shad_colour').match(/[A-Za-z0-9]{2}/g).map(function(v) { return parseInt(v, 16) }).join(",") + ","+opt(line, 'shad_op')+")";

      ctx.shadowBlur = opt(line, 'shad_blur');
    }

    txt.forEach(function(t, i){
      var y = unit * i + unit / 2;
      if(t.startsWith('\\r')) align = 'right';
      if(t.startsWith('\\l')) align = 'left';
      if(t.startsWith('\\c')) align = 'center';
      if(t.startsWith('\\j')) align = 'justify';
      t = t.replace(/\\[^\\]/g,'');
      if(align != 'justify') ctx.textAlign = align; else ctx.textAlign = 'left';
      var text_x = text_start(align, s, bg_start, bg_width);
      //console.log(text_x);

      if(align == 'justify'){
        var threshold = 0;
        if(last_lines.includes(i)) threshold = 0.7; // Could adjust
        justified_text({
          text: t,
          style: s,
          x: text_x,
          y: y_orig+y+translate,
          width: text_width,
          ctx: ctx,
          type: 'fill',
          threshold: threshold
        });
      }else{
        ctx.fillText(t, text_x, y_orig+y+translate); // Fix the x thing for different alignments
      }
    });

    if(opt(line, 'out_size') > 0){
      ctx.restore();
      ctx.strokeStyle = opt(line, 'out_colour');
      ctx.lineWidth = opt(line, 'out_size');
      txt.forEach(function(t, i){
        if(t.startsWith('\\r')) align = 'right';
        if(t.startsWith('\\l')) align = 'left';
        if(t.startsWith('\\c')) align = 'center';
        if(align != 'justify') ctx.textAlign = opt(line, 'text_align'); else ctx.textAlign = 'left';
        var text_x = text_start(align, s, bg_start, bg_width);

        var y = unit * i + unit / 2;
        if(align == 'justify'){
          var threshold = 0;
          if(last_lines.includes(i)) threshold = 0.7; // Could adjust
          justified_text({
            text: t,
            style: s,
            x: text_x,
            y: y_orig+y+translate,
            width: text_width,
            ctx: ctx,
            type: 'stroke',
            threshold: threshold
          });
        }else{
          ctx.strokeText(t, text_x, y_orig+y+translate); // Fix the x thing for different alignments
        }
      });
    }

    if(end_canvas){
      end_ctx.drawImage(canvas, 0, 0);
      //console.log(end_canvas.width, window.video.videoWidth);
    }
    add_cached_canvas(line, canvas);

  }

/*function text_start(align, s = 'default', canvas, bg_start){
  var text_x = canvas.width/2 + proportion('width', window.opts[s].h_offset);

  if(align == 'left') text_x = proportion('width', window.opts[s].h_margin) + proportion('width', window.opts[s].h_offset);
  if(align == 'right') text_x = canvas.width - proportion('width', window.opts[s].h_margin) - proportion('width', window.opts[s].h_offset);
  if(align == 'justify') text_x = bg_start + proportion('width', window.opts[s].h_margin);
  return text_x;
}*/

function text_start(align, s = 'default', bg_start, bg_width){
  var text_x = ((bg_start * 2) + bg_width) / 2;

  if(align == 'left' || align == 'justify') text_x = bg_start + proportion('width', window.opts[s].h_margin);
  if(align == 'right') text_x = bg_start + bg_width - proportion('width', window.opts[s].h_margin);
  return text_x;
}

  function canvas_to_ab_promise(line, type = 'tiff'){
    var canvas = document.createElement('CANVAS');

    draw_subtitle(line, canvas);

    return canvas_to_blob_promise(canvas, type).then((blob) => {
      return blob.arrayBuffer().then((ab) => {
        return {
          img: ab,
          line: line
        };
      });
    });
  }

  function blank_canvas_promise(type = 'tiff'){
    var canvas = document.createElement('CANVAS');
    var ctx = canvas.getContext('2d');

    draw_subtitle({style: 'default', text: ''}, canvas, true); // To avoid duplication!
    return canvas_to_blob_promise(canvas, type).then((blob) => {
      return blob.arrayBuffer();
    });
}

function launch_ffmpeg(params){
  args = params.args;
  files = params.files;

  return new Promise(function (resolve, reject){
    window.worker_promise = {resolve: resolve, reject: reject};
    window.worker.postMessage({
      type: 'command',
      arguments: args,
      TOTAL_MEMORY: 1073741824, // TODO check if needed with vbr, was 268435456
      files: files
    });
  })
}

function init_worker(){
  // Adapted from videoconverter.js - https://github.com/bgrins/videoconverter.js/blob/master/demo/terminal.js
  //if(window.running_locally) return;
  window.bible_worker = new Worker('bible_worker.js');
  bible_worker.onmessage = function (event) {
    var message = event.data;
    if(message.type == "ready") {

    } else if(message.type == 'verse') {
      show_passage(message.data);
    }
  }
  window.worker = new Worker("worker-asm.js");
  worker.onmessage = function (event) {
    var message = event.data;
    if (message.type == "ready") {
      window.isWorkerLoaded = true;
      $('#browser_overlay').show();
      $('#browser_full').show();
      $('#ffmpeg_loading').hide();
      // Probs remove below
    } else if (message.type == "stdout") {
      log_it(message.data);
    } else if (message.type == "stderr") {
      log_it(message.data);
    } else if (message.type == "start") {
      //$('#ffmpeg_log').text("Worker has received command\n");
    } else if (message.type == "done") {
      //console.log('done!',window.worker_promise.resolve);
      if(window.worker_promise.resolve) window.worker_promise.resolve(message.data);
    }
  };
  worker.onerror = function(event){
    console.log('Error from video processor: '+event.message);
    if(window.worker_promise.reject) window.worker_promise.reject(event.message.data);
  }
}

function export_overlay(){
  browser_video(true);
}

function export_full(){
  browser_video(false);
}

function home_ffmpeg(){
  $('#home_ffmpeg').prop('disabled', true);
  $('#home_ffmpeg').text('Preparing download...');
  var just_overlay = $('#just_overlay').is(':checked');
  if(!browser_video(just_overlay, true)){
    $('#home_ffmpeg').prop('disabled', false);
    $('#home_ffmpeg').text('Download DIY materials for FFMPEG');
  }
}

function round_to_frame(d, fps){
  d = sec_to_frame(d, fps);
  d = d / fps;
  return d;
}

function sec_to_frame(d, fps){
  d = d * fps;
  d = Math.round(d);
  return d;
}

async function chain_ffmpeg(params_list){
  var results_list = [];
  ffmpeg_start();
  for(let i = 0; i < params_list.length; i++){
    //console.log('Thread '+i,params_list[i]);
    var r = await launch_ffmpeg(params_list[i]);
    //if(i == 1) download(r[0].data, r[0].name, "video/quicktime");
    var progress = Math.round(i / (params_list.length - 1) * 100).toString()+'%'
    $('#ffmpeg_bar').width(progress);
    $('#ffmpeg_bar').text(progress);
    results_list.push({name: r[0].name, data: new Uint8Array(r[0].data)});
  }
  return results_list.flat();
}

async function concat_ffmpeg(params_list){
  var results_file = '';
  ffmpeg_start();
  for(let i = 0; i < params_list.length; i++){
    //console.log('Thread '+i,params_list[i]);
    var r = await launch_ffmpeg(params_list[i]);
    r = new Uint8Array(r[0].data).join('');
    if(results_file != ''){
      r = r.substring(/[\r\n]/.exec(r).index);
    }
    results_file += r;
    //if(i == 1) download(r[0].data, r[0].name, "video/quicktime");
    var progress = Math.round(i / (params_list.length - 1) * 100).toString()+'%'
    $('#ffmpeg_bar').width(progress);
    $('#ffmpeg_bar').text(progress);
    //results_list.push({name: r[0].name, data: r[0].data});
  }
  return {name: 'input.y4m', data: new Uint8Array(results_file)};
}

function min(a, b){
  if(a > b) return b;
  return a;
}


function close_all_lines(){
  deselect();
  window.timecodes.forEach(function(line, i){
    if(!line.end){
      if(i == window.timecodes.length - 1){
        tc_set_end(i, window.video.duration);
      }else{
        tc_set_end(i, window.timecodes[i+1].start);
      }
    }
  });
}

function browser_video(just_overlay, zip = false){
  var method = 'concat'; // Could also be overlay?
  var fn = '';
  var stored = false; //'tiff';
  var img_seq = false;
  var fps = 25;
  var single_frame = (1/fps);
  var output_type = $('#codec').val();

  //var start_time = new Date()

  if(method == 'promises') img_seq = true;

  //if(zip) img_type = 'png'; // Less memory!

  var rate_settings = {
    rate: '-r '+fps+' ',
    cfr: '-r '+fps+' -vsync cfr ',
    vfr: '-r '+fps+' -vsync vfr ',
    drop: '-r '+fps+' -vsync drop ',
    none: ' '
  }
  var rate = '';
  if(method == 'concat' || method == 'promises'){
    rate = rate_settings[$('#rate').val()];
  }


  var output_formats = {
    prores: '-c:a copy -c:v prores_ks -profile:v 4444 -vendor ap10 -pix_fmt yuva444p10le -q:v 9 -alpha_bits 8 '+rate+'overlay.mov',
    prores_noalpha: '-c:a copy -c:v prores_ks -profile:v standard -vendor ap10 -q:v 11 '+rate+'overlay.mov',
    h264: '-strict -2 -c:a aac -c:v libx264 -preset veryfast -profile:v main -pix_fmt yuv420p '+rate+'overlay.mp4',
    quicktime: '-c:a copy -c:v qtrle -vendor ap10 -pix_fmt argb '+rate+'overlay.mov',
    png: '-c:a copy -c:v png '+rate+'overlay.mov',
    vp8: '-c:a copy -c:v libvpx -pix_fmt yuva420p -crf 0 -metadata:s:v:0 alphamode="1" '+rate+'overlay.webm',
    hevc: '-c:a copy -c:v libx265 -crf 0 -preset ultrafast '+rate+'overlay.mp4',
    ayuv: '-c:a copy -c:v ayuv '+rate+'overlay.avi',
    v408: '-c:a copy -c:v v408 '+rate+'overlay.mov'
  };

  var chosen_format = output_formats[output_type];

  //if(zip)
  if(window.opts._global.fades) method = 'blank_fade';//'zoompan'; //;

  if(window.timecodes.length < 1){
    alert('Nothing to export yet â€“ add some subtitles!');
    return;
  }

  if(!check_text_width()){
    // Offer option to fix it
    if(!confirm("Font size is too big! Some subtitles won't fit on screen. Click 'OK' to export anyway and 'Cancel' to go back and fix font size.")){
      var evt = new MouseEvent('click', {view: window, bubbles: true, cancelable: true});
      $('#opt_tab')[0].dispatchEvent(evt);
      return;
    };
  }

  if(storageAvailable('localStorage')){
    // Auto-save in case we run out of memory
    var tc = get_json();
    localStorage.setItem('autosave', tc);
  }

  var save_setting = window.opts._global.min_height;
  if(!just_overlay){
    window.opts._global.min_height = false;
    window.cached_canvases = {}; // Need to redraw
  }

  // Don't do the whole encode
  blank_canvas_promise(window.img_type).then(function(blank){
    var img_promises = [];
    close_all_lines();
    window.timecodes.forEach(function(line){
      img_promises.push(canvas_to_ab_promise(line, window.img_type));
      //console.log('added '+line.text);
    });
    if(!just_overlay){
      if(!window.vid_name){
        alert('No video loaded to overlay yet!');
        return false;
      }
      fn = window.vid_name.match(/\.(.+)$/);
      if(!fn){
        alert("Video has no extension: ffmpeg cannot process it!");
        return false;
      }
      fn = fn[1];
      if(!zip) img_promises.push(fetch($('#video_here')[0].src).then(function(r){ // Only do this if you really need to
        return r.blob().then(function(b){
          return b.arrayBuffer().then((ab) => {
            return {
              img: ab,
              main_vid: true,
              line: {
                start: 0,
                end: 0
              }
            }
          });
        });
      }));
    }

    window.opts._global.min_height = save_setting;
    window.cached_canvases = {};
    prerender();

    Promise.all(img_promises).then(function(blobs) {
      //console.log('Blobbed');
      //console.log('Promise resolved');
      //var args = '-formats';
      var bn = 'blank.'+window.img_type;
      var blank_data = new Uint8Array(blank);
      //download(blank_data, "blank.png", "image/png");
      var files = [{
        name: bn,
        data: blank_data
      }];
      var concat_file = 'ffconcat version 1.0\n';
      //var sources = [];
      var args = [];
      var args_opening = '-nostdin -debug_ts'

      var duration_list = [];
      args.push(...args_opening.split(' '));

      blobs.sort(function(a,b){a.line.start - b.line.start}); // Just in case they are disordered by the Promise

      var position = 0;

      if(!just_overlay){
        args.push('-i',window.vid_name); // First one
        if(fn == 'mov'){
          output_type = 'prores_noalpha'; // Presume Apple video in a ProRes container
        }else{
          output_type = 'h264'; // Anything else presume H.264
        }
      }else{
        output_type = $('#codec').val();
      }

      var i_aug = 0;
      blobs.forEach(function(blob){
        blob.line.end = round_to_frame(blob.line.end, fps);
        blob.line.start = round_to_frame(blob.line.start, fps)
      });

      blobs = blobs.filter(b => b.line.end > b.line.start); // Should get rid of empty ones

      blobs.forEach(function(blob, i){

        var data = new Uint8Array(blob.img);
        if(blob.main_vid){
          files.push({
            name: window.vid_name,
            data: data
          });
          return;
        }

        if(blob.line.start > position){
          var gap = blob.line.start - position;
          if(img_seq){
            n = i+i_aug;
            i_aug++;
            bn = 'img-'+n+'.'+window.img_type;
            files.push({name: bn, data: blank_data});
          }

          duration_list.push({file: bn, dur:gap.toFixed(3)});
          gap -= single_frame;
          concat_file += "file '"+bn+"'\nduration "+gap.toFixed(3)+'\n';
          concat_file += "file '"+bn+"'\nduration "+single_frame.toFixed(3)+'\n';
          position = blob.line.start;
        }

        var n = i+i_aug;
        var fn = 'img-'+n+'.'+window.img_type;
        files.push({name: fn, data: data});

        var dur = blob.line.end - blob.line.start;
        //if(dur > 0)
        duration_list.push({file: fn, dur: dur.toFixed(3)});
        dur -= single_frame;
        position = blob.line.end;
        if(dur.toFixed(3) >  0){
          concat_file += "file '"+fn+"'\nduration "+dur.toFixed(3)+'\n';
        }
        concat_file += "file '"+fn+"'\nduration "+single_frame.toFixed(3)+'\n';
        //sources.push({num: i+1, start: blob.line.start, end: blob.line.end});
      });

      if(window.opts._global.bg_visible && position < window.video.duration){
        // Pad to end
        if(img_seq){
          i_aug++;
          n = i+i_aug;
          bn = 'img-'+n+'.'+window.img_type;
        }
        files.push({name: bn, data: blank_data});
        var gap = window.video.duration - position;

        duration_list.push({file: bn, dur: gap.toFixed(3)});
        gap -= single_frame;
        if(gap.toFixed(3) > 0){
          concat_file += "file '"+bn+"\nduration "+gap.toFixed(3)+'\n';
          position += gap;
        }
        concat_file += "file '"+bn+"\nduration "+single_frame.toFixed(3)+'\n';
      }


      if(method == 'concat'){
        var concat_data = new Uint8Array(concat_file);
        files.push({name: 'concat.txt', data: concat_file});
        var concat_args = '-f concat -i concat.txt';
        args.push(...concat_args.split(' '));
        if(!just_overlay){
          // offset should be dealt with by suspending min-height
          args.push('-filter_complex','[0][1]overlay=x=0:y=0:repeatlast=0');
        }
      }else if(method == 'promises'){
        var ffmpeg_params = [];
        var output_file = chosen_format.split(' ').slice(-1);

        var new_durations = duration_list.filter(f => f.file.startsWith('img'));
        var fade_dur = window.opts._global.fade_dur;
        var fades = [];
        var last_fade = 0;

        new_durations.forEach(function(e,i){
          var curr_dur = parseFloat(e.dur);
          var fd = fade_dur;
          if(i > 0) curr_dur -= last_fade;
          var next_dur = fade_dur;
          if(i < new_durations.length-1){
            next_dur = parseFloat(new_durations[i+1].dur);
          }
          if(fd > curr_dur || fd > next_dur) fd = min(curr_dur, next_dur);
          if(last_fade > fd){
            var avg = (last_fade + fd)/2;
            fades[fades.length - 1] = avg;
            fd = avg;
          }
          fades.push(fd);
        });

        var last_fade = 0;
        console.log(fades);

        new_durations.forEach(function(e,i){
          //var new_file = e.file.replace('tiff','mov');
          //new_file = new_file.replace('webp','mov');
          var dur = parseFloat(e.dur);
          var fd = fades.shift();
          dur -= last_fade;


          var out_time = dur - fd;
          out_time = out_time.toFixed(3);
          fd = fd.toFixed(3);
          dur = dur.toFixed(3);
          var static_leafname = e.file.replace(/\..+/, '');
          var fade_leafname = e.file.replace(/\..+/, 'f');

          // At this point then, the static image lasts out_time, and the fade lasts fd. So just add those for now.
          var static_args_string = "-loop 1 -t "+out_time+" -i "+e.file+' '+chosen_format.replace('overlay', static_leafname);

          var specific_files = [ files.find(element => element.name == e.file) ];

          if(i < new_durations.length-1){
            // Add filters here
            fade_args_string = '-loop 1 -t '+fd+' -i '+e.file+' -loop 1 -t '+fd+' -i '+new_durations[i+1].file+" -filter_complex [0]alphaextract,fade=t=out:d="+fd+"[a0];[0][a0]alphamerge[f0];[1]alphaextract,fade=t=in:d="+fd+"[a1];[1][a1]alphamerge[f1];[f0][f1]overlay"   //' -vf zoompan=d='+fd+':fps=1/'+fd+',framerate='+fps+':interp_start=0:interp_end=255:scene=100';
            specific_files.push(files.find(element => element.name == new_durations[i+1].file));
          }else{
            var fade_args_string = "-loop 1 -t "+fd+" -i "+e.file+' -filter_complex fade=t=out:d='+fd+':alpha=1';
          }

          var static_list = static_args_string.split(' ');
          if(out_time > 0) ffmpeg_params.push({args: static_list, files: [files.find(element => element.name == e.file)] });

          var fade_list = fade_args_string.split(' ');


          var fade_output = chosen_format.replace('overlay', fade_leafname);
          fade_list.push(...fade_output.split(' '));
          ffmpeg_params.push({args: fade_list, files: specific_files});

          /*var filter_args = '[0]format=yuva444p,fade=t=out:st='+out_time+':d='+fd;
          var dur_args = "-loop 1 -t "+dur+" -i "+e.file;
          if(i < new_durations.length-1){
            dur_args += ' -loop 1 -t '+dur+' -i '+new_durations[i+1].file; //[0]format=yuva444p,fade=t=out:st='+out_time+':d='+fd+'[f0];
            var filter_args = "[0][1]blend=all_mode=overlay:all_expr='A*(1-if(gte(T,"+out_time+"),1,(T - "+out_time+")/"+fd+"))+B*((if(gte(T,"+out_time+"),1,(T - "+out_time+")/"+fd+")))'";//:enable='between(t\\,"+out_time+"\\,"+dur+")'";
          }
          var format_args = chosen_format.replace('overlay', e.file.replace(/\..+/, ''));

          args_list = [];
          args_list.push(...dur_args.split(' '));

          // fade
          args_list.push('-filter_complex');
          args_list.push(filter_args);


          args_list.push(...format_args.split(' '));

          //+" -r "+fps+" -vsync vfr -c:v qtrle -pix_fmt bgra "+new_file;
          //var dur_args = "-loop 1 -t "+e.dur+" -i "+e.file+" -r "+fps+" -vsync vfr -f yuv4mpegpipe "+new_file;
          //console.log(dur_args)
          //var args_list = dur_args.split(' ');
          var specific_file = files.find(element => element.name == e.file);
          var these_files = [ specific_file ];
          if(i < new_durations.length-1){
            these_files.push(files.find(element => element.name == new_durations[i+1].file));
            //console.log(these_files);
          }
          ffmpeg_params.push({args: args_list, files: these_files});*/
        })

        chain_ffmpeg(ffmpeg_params).then(function(results){

          //download(results[0].data, results[0].name, 'video/quicktime');
          var concat_file = '';
          var concat_args = '';
          var size_sum = 0;
          var count = 0;
          //files = []; // Free up all those old files
          results.filter(f => f.name.startsWith('img')).forEach(function(f){
            concat_file += "file '"+f.name+"'\n";
            concat_args += ' -f avi -i '+f.name;
            files.push(f);
            size_sum += f.data.byteLength;
            count++;
          })
          var avg = size_sum / count; // / duration_list.reduce((total, e) => {return total + parseFloat(e.dur)});
          console.log('Average file size per sec', avg);
          //console.log(files);
          //console.log(concat_file);
          var concat_data = new Uint8Array(concat_file);
          files.push({name: 'concat.txt', data: concat_file});
          var concat_format = '-f concat -i concat.txt';
          args.push(...concat_format.split(' '));
          //args.push(...concat_args.split(' '));
          /*args.push('-filter_complex');
          var filter_args = 'concat=n='+duration_list.length;
          if(!just_overlay){
            var streams = '';
            duration_list.forEach(function(e, i){
              var s = i+1;
              streams += '['+s+']';
            })
            // offset should be dealt with by suspending min-height
            filter_args = streams+filter_args+'[v];[0][v]overlay=x=0:y=0:repeatlast=0';
          }
          args.push(filter_args);*/
          //args.push(...chosen_format.split(' '));
          var out_format = '-c:a copy -c:v copy '+output_file;
          args.push(...out_format.split(' '));
          ffmpeg_start();
          console.log('Launching ffmpeg with args '+args.join(' '));

          launch_ffmpeg({args: args, files: files}).then(function(buffers){
            ffmpeg_stop();
            buffers.forEach(function(file) {
              download(file.data, file.name, "video/quicktime");
            });
            if(storageAvailable('localStorage')){
              // Delete autosave
              localStorage.removeItem('autosave');
            }
          });
        });

      }else if(method == 'blank_fade'){

        var join_args = '';
        var filter_args = '';
        var input_args = '';
        var overlay_args = '';
        var fade_dur = window.opts._global.fade_dur;
        var total_dur = 0;
        var input_aug = (just_overlay) ? 0 : 1;
        var reduced_blank = false;
        // TODO handle a limit of blank length for fades, and refactor to suit. I think simplest
        // would be to limit it to fade_dur * 2 for the middle as then a lot of the edge cases below would be gone.
        // Could still allow for smaller at start or end if you like.

        duration_list.forEach(function(e, i){
          var overlay_num = input_aug;
          var overlay_stream = '['+overlay_num+']';
          if(e.file == 'blank.'+window.img_type && i > 0 && duration_list[i-1].file != 'blank.'+window.img_type){
            // Blank after non-blank
            //console.log('blank after non-blank',i);
            var fade_amount = fade_dur;
            e.dur = parseFloat(e.dur);
            if(e.dur < fade_amount){
              fade_amount = e.dur;
            }
            e.dur -= fade_amount;
            e.dur = e.dur.toFixed(3);
          }if(e.file == 'blank.'+window.img_type && i < duration_list.length - 1 && duration_list[i+1].file != 'blank.'+window.img_type){
            // Blank before non-blank
            //console.log('blank before non-blank',i);
            var fade_amount = fade_dur;
            e.dur = parseFloat(e.dur);
            if(e.dur < fade_amount) fade_amount = e.dur;
            e.dur -= fade_amount;
            e.dur = e.dur.toFixed(3);
          }else if(e.file != 'blank.'+window.img_type){
          //  console.log('non-blank');
            if(i > 0 && duration_list[i-1].file == 'blank.'+window.img_type){
              // Non-blank after blank
              //console.log('blank before');
              var fade_amount_1 = fade_dur;
              if(parseFloat(duration_list[i-1].dur) < fade_amount_1) fade_amount_1 = parseFloat(duration_list[i-1].dur);
              //console.log(fade_amount_1);
              if(i < duration_list.length - 1 && duration_list[i+1].file == 'blank.'+window.img_type){
                // Blank sandwich!
                var join = overlay_stream;
                //console.log('fade in and output',i);
                if(fade_amount_1 > 0){
                  e.dur = parseFloat(e.dur) + fade_amount_1;
                  e.dur = e.dur.toFixed(3);
                  var new_overlay = '[f'+overlay_num+']';
                  filter_args += overlay_stream+'fade=t=in:d='+fade_amount_1+':alpha=1';
                  join = ',';
                }
                var fade_amount_2 = fade_dur;
                if(parseFloat(duration_list[i+1].dur) < fade_amount_2) fade_amount_2 = parseFloat(duration_list[i+1].dur);
                if(fade_amount_2 > 0){
                  e.dur = parseFloat(e.dur) + fade_amount_2; // On each side!
                  var out_start = e.dur - fade_amount_2;
                  e.dur = e.dur.toFixed(3);
                  out_start = out_start.toFixed(3);
                  var new_overlay = '[f'+overlay_num+']';
                  filter_args += join+'fade=t=out:st='+out_start+':d='+fade_amount_2+':alpha=1'+new_overlay+';';
                  overlay_stream = new_overlay;
                }
              }else if(i == duration_list.length - 1 && total_dur + parseFloat(e.dur) < window.video.duration){
                // Blank sandwich with ending!
                var join = overlay_stream;
                //console.log('blank to end');
                if(fade_amount_1 > 0){
                  e.dur = parseFloat(e.dur) + fade_amount_1;
                  e.dur = e.dur.toFixed(3);
                  var new_overlay = '[f'+overlay_num+']';
                  filter_args += overlay_stream+'fade=t=in:d='+fade_amount_1+':alpha=1';
                  join = ',';
                }
                var fade_amount_2 = fade_dur;
                var diff = window.video.duration - parseFloat(e.dur) - total_dur;
                if(diff < fade_amount_2) fade_amount_2 = diff;
                if(fade_amount_2 > 0){
                  e.dur = parseFloat(e.dur) + fade_amount_2;
                  var out_start = e.dur - fade_amount_2;
                  //e.dur += 0.5; //Pad
                  e.dur = e.dur.toFixed(3);
                  out_start = out_start.toFixed(3);
                  var new_overlay = '[f'+overlay_num+']';
                  filter_args += join+'fade=t=out:st='+out_start+':d='+fade_amount_2+':alpha=1'+new_overlay+';';
                  overlay_stream = new_overlay;
                }
              }else{
                // Just fade in
                //console.log('fade in',i);
                if(fade_amount_1 > 0){
                  e.dur = parseFloat(e.dur) + fade_amount_1;
                  e.dur = e.dur.toFixed(3);
                  var new_overlay = '[f'+overlay_num+']';
                  filter_args += overlay_stream+'fade=t=in:d='+fade_amount_1+':alpha=1'+new_overlay+';';
                  overlay_stream = new_overlay;
                }
              }
            }else if(i < duration_list.length - 1 && duration_list[i+1].file == 'blank.'+window.img_type){
              // Non-blank before blank - just fade out
              //console.log('fade out',i);
              var fade_amount_2 = fade_dur;
              if(parseFloat(duration_list[i+1].dur) < fade_amount_2) fade_amount_2 = parseFloat(duration_list[i+1].dur);
              if(fade_amount_2 > 0){
                e.dur = parseFloat(e.dur) + fade_amount_2;
                var out_start = e.dur - fade_amount_2;
                e.dur = e.dur.toFixed(3);
                out_start = out_start.toFixed(3);
                var new_overlay = '[f'+overlay_num+']';
                filter_args += overlay_stream+'fade=t=out:st='+out_start+':d='+fade_amount_2+':alpha=1'+new_overlay+';';
                overlay_stream = new_overlay;
              }
            }else if(i == duration_list.length - 1 && total_dur + parseFloat(e.dur) < window.video.duration){
              //console.log('early end',i);
              var fade_amount_2 = fade_dur;
              var diff = window.video.duration - parseFloat(e.dur) - total_dur;
              if(diff < fade_amount_2) fade_amount_2 = diff;
              if(fade_amount_2 > 0){
                e.dur = parseFloat(e.dur) + fade_amount_2;
                var out_start = e.dur - fade_amount_2;
                //                                                       e.dur += 0.5; //Pad
                e.dur = e.dur.toFixed(3);
                out_start = out_start.toFixed(3);
                var new_overlay = '[f'+overlay_num+']';
                filter_args += overlay_stream+'fade=t=out:st='+out_start+':d='+fade_amount_2+':alpha=1'+new_overlay+';';
                overlay_stream = new_overlay;
              }
            }else{
              //console.log('nowt special',i);
            }
          }

          if(parseFloat(e.dur) > 0){
            // i.e. only bother if it's long enough
            input_args += '-loop 1 -t '+e.dur+' -i '+e.file+' ';
            join_args += overlay_stream;
            input_aug++;
            total_dur += parseFloat(e.dur);
          }else{
            //input_args += '-loop 1 -t  1 -i '+e.file+' '; // just a placeholder TODO fix
          }
        });
        //input_aug--;
        join_args += 'concat=n='+input_aug+'[v]';
        var out_stream = '[v]';

        if(!just_overlay){
          join_args += ';[0][v]overlay=x=0:y=0:repeatlast=0[out]';
          out_stream = '[out]';
        }
        filter_args += join_args;
        args.push(...input_args.trim().split(' '));
        args.push('-filter_complex', filter_args);
        args.push('-map', out_stream);

        if(!just_overlay) args.push('-map', '0:a?'); // to map audio from main stream
      }

      //console.log(data);
      //var avi_args =  '-nostdin -loop 1 -i img.png -c:v huffyuv -t 15 out.avi';

      if(method != 'promises') args.push(...chosen_format.split(' '));

      if(zip){
        // Don't actually run FFMPEG in browser, instead export the files to do at home

        var command = 'ffmpeg';
        args.forEach(function(a, i){
          if(/[\s;&]/g.test(a)) a = '"' + a + '"'; //Â To escape spaces or anything else that bash might not like
          if(a == 'ultrafast') a = 'veryfast';
          if(a == '-debug_ts') return; // Skip debug info
          command += ' ';
          command += a;
        });
        var export_zip = new JSZip();
        files.forEach(function(f){

          export_zip.file(f.name, f.data);
        });
        export_zip.generateAsync({type: "uint8array"}).then(function(f){
          download(f, 'diy_overlay.zip', 'application/zip');
          $('#ffmpeg_command').val(command);
          $('#ffmpeg_command')[0].select();
          $('#ffmpeg_command')[0].setSelectionRange(0,99999);
          if(document.execCommand("copy")){
            $('#confirmation').text('Command has been copied to clipboard (and is in textbox below)');
          }else{
            $('#confirmation').text('');
          }
          localStorage.removeItem('autosave'); // Because we're not calling anything
          $('#home_ffmpeg').prop('disabled', false);
          $('#home_ffmpeg').text('Download DIY materials for FFMPEG');
        });
      }else if(method != 'promises'){
        if(ffmpeg_ready()){
          ffmpeg_start();
          // TODO check whether memory amounts below are needed!
          console.log('Launching ffmpeg with args '+args);
          //args = ['-codecs'];
          launch_ffmpeg({args: args, files: files}).then(function(buffers){
            ffmpeg_stop();
            buffers.forEach(function(file) {
              download(file.data, file.name, "video/quicktime");
            });
            if(storageAvailable('localStorage')){
              // Delete autosave
              localStorage.removeItem('autosave');
            }
          });
        }else{
          alert('FFMPEG is not loaded yet! Please wait and try again once it has loaded.');
        }
      }
    });

  });
  return true;
}

function hms_to_secs(text){
  const res = text.match(/([0-9]?[0-9]0):([0-9][0-9]):([0-9][0-9])[\.,]([0-9][0-9])/);
  if(res.length > 0){
    hrs = parseInt(res[1]);
    mins = parseInt(res[2]);
    secs = parseInt(res[3]);
    hs = parseInt(res[4]);
    return hrs * 3600 + mins * 60 + secs + hs / 100;
  }else{
    return 0;
  }
}

function log_it(text) {
  res = text.match(/frame_pts_time:(\S+)\s/);
  if(res && res.length > 0){
    var so_far = res[1];
    var final_duration = window.timecodes[window.timecodes.length - 1].end;
    if($('#just_overlay').is(':checked') || window.opts._global.bg_visible) final_duration = window.video.duration;
    //console.log(so_far, final_duration, so_far / final_duration);
    var progress = Math.round(so_far / final_duration * 100).toString()+'%'; // Judge by length of overlay not video
    var current_text = $('#ffmpeg_bar').text();
    if(parseInt(progress) > parseInt(current_text)){
      $('#ffmpeg_bar').width(progress);
      $('#ffmpeg_bar').text(progress);
    }
  }else{
    var res = text.match(/pts_time:(\S+)\s/);
    if(res && res.length > 0) return; // Discard any other pts_time stuff
    $('#ffmpeg_log').append(document.createTextNode(text+"\n"));
    $("#ffmpeg_log").scrollTop($("#ffmpeg_log")[0].scrollHeight);
  }
}

function adjust_range(){
  var range_id = $(this).attr('id');
  var id = range_id.slice(0, -6); // To remove '_range' bit
  $('#'+id).val($(this).val());
  change_opt.call(document.getElementById(id), {}, true);
  //$('#'+id).trigger('change');
}

function superscript(text){
  return text;
  /*var res = '';
  for(let i = 0; i < text.length; i++){
    var code = text.charCodeAt(i) + 0x2040;
    //code = ('0000' + code.toString(16).toUpperCase()).slice(-4)
    //console.log(text.charAt(i));
    switch(text.charAt(i)){
      case '1':
        res = res.concat('\u00B9');
        break;
      case '2':
        res = res.concat('\u00B2');
        break;
      case '3':
        res = res.concat('\u00B3');
        break;
      case 'a':
        res = res.concat('\u1d43');
        break;
      case 'b':
        res = res.concat('\u1d47');
        break;
      case 'c':
        res = res.concat('\u1d9c');
        break;
      case 'd':
        res = res.concat('\u1d48');
        break;
      case '4': case '5': case '6': case '7': case '8': case '9':
        res = res.concat(String.fromCharCode(text.charCodeAt(i) + 0x2040));
        break;
      default:
        res = res.concat(text.charCodeAt(i));
    }
  }
  return res;*/
}

function add_verse(){
  var passage = $('#single_line').val();
  if(passage == '') return;
  var version = $('#bible_version').val();
  if(version == 'custom') version = $('#bible_name').val();
  bible_passage(passage, version);
}

function bible_version(){
  if($('#bible_version').val() == 'custom') $('#bible_custom').show();
  else $('#bible_custom').hide();
}

function show_passage(result){
  var all = '';
  $(result).find('.passage-content *').each(function(){
    //console.log(this);
    if(this.nodeType == 1 && $(this).hasClass('text') && $(this).parent('h3').length == 0){
      var ch = '';
      var num = '';
      if(all.length > 0){
        // Add chapters in middle
        ch = $(this).find('.chapternum').text();
        if(ch) ch = '\nChapter '+ch+'\n';
      }
      if($('#verse_numbers').is(':checked')) num = $(this).find('.versenum').text();
      $(this).find('.versenum').remove();
      $(this).find('.chapternum').remove();
      $(this).find('.footnote').remove();
      //console.log(superscript(num));
      all += ch+superscript(num)+$(this).text()+' '; //TODO check newline ok
    }
  })
  //console.log($(result));
  $(result).find('.chapternum').each(function(){
    var num = $(this).text();
    $(this).text('Chapter '+num+'\n');
  })
  //$(result).find('.text').each( function(){
  //  all += $(this).text()+' ';
//});
  //all = all.slice(0, -7);
  all += '\n\\r'+passage;
  $('#single_line').val(all);
  add_line();
}

function bible_callback(json){
  var all = json;//JSON.parse(json);
  var passage = $('#single_line').val();
  $('#single_line').val(all);
  add_line();
}

function bible_passage(passage, version = 'NIV'){
  //var api_key = '30a80e79b9aac1a77b8bdb334f03a03f';
  /*$.ajax({
    url: "http://api.biblia.com/v1/bible/parse?passage="+encodeURIComponent()
  })*/
  passage = passage.replace(/\s/g,'');
  passage = passage.replace(/:/g,'.');

  var url = "https://bible-api.com/"//"https://api.biblia.com/v1/bible/content/"+version+".txt.json?passage="+encodeURIComponent(passage)+"&key=30a80e79b9aac1a77b8bdb334f03a03f&callback=?";///+api_key;
  $.getJSON(url, function(result){
    bible_callback(result);
  });
}

</script>
</head>
<body>
  <div id="header" class="w3-container w3-blue">
    <h1>Make your own lyrics video!</h1>
  </div>
  <p>Choose a video or audio file to work with: <input type="file" id="vid_file" accept="video/*,audio/*,.mov,.m4v,.mkv,.avi,.mp4,.wav,.aiff,.mp3"/></p>
  <p id="autosave" style="color: green;">Your work-in-progress was automatically restored after the export ran out of memory. You can try another export method.</p>
  </div><div id="loadsave"><button class="w3-btn w3-blue" id="save_subs">Save work in progress </button> Or load from a previous save: <input type="file" id="sub_file" accept=".json"/></div>
    <div id="video_proportions">
    <p>Show video at <div class="percentage"><input type='range' min='1' max='100' value='50' class='slider' id='video_size_range'/>
      <input id="video_size" class="opt_control global" type="number" min="1" max="100" value="50" size="3"/> % of original size<span class="tooltiptext"></span></div>
      <button id="float" class="w3-btn w3-blue">Float video to right</button>
    </div>
    <div id="audio_settings">
      Size of video: <input id="vid_x" class="resize_vid" type="number" value="1024" /> x <input id="vid_y" class="resize_vid" type="number" value="768" />
    </div>
  </p>
  <div id="vc_container">
    <div id="video_container"><video playsinline id="vid" controls="true">
      <source src="http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4" id="video_here" />
      Your browser does not support HTML5 video.
    </video><div id="preview_container"><canvas id="canvas">Your browser does not support HTML canvas.</canvas></div></div>
  </div>
  <p />
  <div class="w3-bar w3-black">
    <button class="w3-bar-item w3-button tablink w3-blue" onclick="openTab(event, 'add_lyrics')">Import</button>
    <button class="w3-bar-item w3-button tablink" id="place_tab" onclick="openTab(event, 'place_lyrics','place')">Place</button>
    <button class="w3-bar-item w3-button tablink" id="verse_tab" style="display: none;" onclick="openTab(event, 'place_lyrics','verse')">Verse</button>
    <button class="w3-bar-item w3-button tablink" onclick="openTab(event, 'edit_lyrics')">Edit</button>
    <button class="w3-bar-item w3-button tablink" id="opt_tab" onclick="openTab(event, 'options')">Format</button>
    <button class="w3-bar-item w3-button tablink" onclick="openTab(event, 'export')">Export</button>
  </div>
  <div id="add_lyrics" class="tab_option">
    <h2>Import lyrics</h2>
    <p>Copy your lyrics here, then press 'Process lyrics!' (or hit ctrl-return) to split into subtitles:</p>
    <p><span>Default lines per subtitle (empty lines will still split subtitles): <input id="subtitle_lines_range" type='range' min='1' max='5' value='1' class= 'slider'/>
      <input id="subtitle_lines" type="number" class="opt_control global" min="1" max="5" value="1" size="1"/></span></p>
      <p><textarea id="lyrics" class="w3-input w3-border" rows=10></textarea></p>
      <button class="w3-btn w3-black" type="button" id="clear">Clear</button>
      <button class="w3-btn w3-blue" type="button" id="process">Process lyrics!</button>
    </div>
    <div id="place_lyrics" class="tab_option" style="display: none;">
      <h2 class="lyrics_opts">Place subtitles</h2><h2 class="verse_opts">Place Bible verse</h2>
      <details><summary>Click here for information on controls (placing lyrics, editing text, splitting and joining lines)</summary>
        Here you can:
        <ul>
          <li>Click on a lyric to make it appear at this moment;</li>
          <li>Click again (or press delete or escape) to make it disappear (or click 'end current lyric', or just click the next lyric);</li>
          <li>Press the up and down arrows to select the next or previous lyric;</li>
          <li>Press space to start and stop the video;</li>
          <li>Shift-click on a lyric to edit its text in the board before you add it;</li>
          <li>Press the 'split' and 'join' buttons when they appear to adjust how many lines appear in a lyric.</li>
        </ul>
        <b>Special codes:</b> You can add the following codes to your text for formatting:
        <ul>
          <li>\l, \c, \r, \j at the start of a line to align left, centre, right or justified</li>
        </ul>
      </details>
      <p class="lyrics_opts">If you want to add and display another lyric quickly, you can type it here and press enter:</p>
      <p class="verse_opts">To add a Bible passage, enter the reference here and choose the Bible version on the right:</p>
      <div class="w3-row single_line_container"><textarea id="single_line" class="w3-quarter w3-input w3-border mousetrap" rows="1"></textarea>
        <span class="lyrics_opts"><button class="w3-btn w3-blue" type="button" id="add">Display</button> Current style:<select class="styles_list"></select><button class="w3-orange w3-btn" id="deselect_lyric">End current lyric</button>
        <button class="w3-btn w3-green fit_to_screen" type="button">Fit text to video width</button>
        <button class="w3-btn w3-blue" id="split_lyric">Split selected subtitle</button>
        <button class="w3-btn w3-blue" id="join_lyric">Join to next subtitle</button>
      </span><span class="verse_opts">
      <button class="w3-btn w3-blue" type="button" id="add_verse">Fetch verse and display</button>
      <input id="verse_numbers" class="w3-check" type="checkbox"/><label>Show verse numbers? </label>
      Bible version:
      <select id="bible_version">
        <option value="NIV">NIV</option>
        <option value="GNT">GNT</option>
        <option value="NRSV">NRSV</option>
        <option value="CEV">CEV</option>
        <option value="MSG">The Message</option>
        <option value="custom">Custom</option>
      </select>
      <span id="bible_custom">Custom: <input id="bible_name" /></span>
      </span>
      </div>
        <div id="lyrics_array" class="lyrics_array"></div>
        <button class="w3-btn w3-black" type="button" id="clear_board">Empty lyrics board</button>
      </div>
      <div id="edit_lyrics" class="tab_option" style="display: none;">
        <h2>Edit subtitles</h2>
        <p>
          <details><summary>Click here for information on controls (editing subtitles, changing timings, 'ripple' edits)</summary>
            Here you can:
            <ul>
              <li>Click on times to jump to them in the video;</li>
              <li>Click on subtitle text to edit it;</li>
              <li>Shift-click to set to current time;</li>
              <li>Shift-alt-click to set to current time and 'ripple' all subsequent subtitles backwards or forwards to compensate (useful if you've trimmed the start of your video or added a clip in the middle).</li>
            </ul>
            You can undo changes by pressing ctrl/cmd-Z, and redo them with shift-ctrl/cmd-Z. (Or press the buttons that appear!)
          </details>
        </p>
        <div>
          <button class="w3-btn w3-blue" id="undo_button">Undo</button>
          <button class="w3-btn w3-blue" id="redo_button">Redo</button>
        </div>
        <div id="selected_options">Change style of selected lyrics:<select id="style_selected"></select>
        <button class="w3-btn w3-red" id="delete_selected">Delete selected lyrics</button></div>
        <div id="list" class="lyrics_array" style="font-family: monospace; white-space:pre;"></div>
        <button class="w3-btn w3-red" id="delete_all" type="button">Delete all subtitles</button>
      </div>
      <div id="options" class="tab_option" style="display: none;">
        <h2>Format subtitles</h2>
        <div class="w3-panel" id="named_styles">
          Current style: <select class="styles_list" id="styles_list"></select> <button class="w3-button w3-red" id="delete_style">Delete style</button>
          Make new style with name: <input type="text" id="new_style_name"/> <button class="w3-button w3-blue" id="make_style">Make style</button>
        </div>
        <div class="w3-panel w3-cell">
          <div class="w3-container w3-blue"><h3>Text</h3></div>
          <div id="text_opts">
            <label>Text colour:</label><input class="opt_control" type='color' id='text_colour' value='#ffffff'/>
            <label>Text size:</label><div class="percentage"><input type='range' min='0.1' max='20' step="0.1" value='5' class='slider' id='font_size_range'/>
            <input id="font_size" class="opt_control" type="number" min="0.1" max="100" value="5" size="1" /> % of width of video<span class="tooltiptext"></span></div>
          </div><div><input id="wrap" class="w3-check opt_control" type="checkbox"/><label>Auto-wrap text? </label><button type="button" id="fit_width" class="w3-btn w3-green">Fit to width</button>
            <div id="size_warning"></div>
          </p><p>
            Font: <input id="font" class="opt_control" type="text" value='sans-serif' size="20"/> (You can type any on your system)
          </p>
          <p>
            Align: <select id="text_align" class="opt_control"><option value="left">Left</option><option value="center" selected>Centred</option><option value="right">Right</option><option value="justify">Justified</option></select>
            Vertical: <select id="v_align" class="opt_control"><option value="top">Top</option><option value="middle" selected>Middle</option><option value="bottom">Bottom</option></select>
            Style options: <input id="bold" class="w3-check opt_control" type="checkbox" value="false"/><label>Bold</label>
            <input id="italic" class="w3-check opt_control" type="checkbox" value="false"/><label>Italic</label>
          </p>
          <p>
            Outline colour: <input class="opt_control" type='color' id='out_colour' value='#000000'/>
            Outline thickness: <input type='range' min='0' max='10' value='0' class='slider' id='out_size_range' />
            <input id="out_size" class="opt_control" type="number" min="0" max="10" value="0" size="3"/> pixel(s)
          </p>
          <p>
            Shadow colour: <input class="opt_control" type='color' id='shad_colour' value='#000000'/>
            Shadow offset: <input type='range' min='0' max='20' value='0' class='slider' id='shad_off_range' />
            <input id="shad_off" class="opt_control" type="number" min="0" max="20" value="0" size="3"/> pixel(s)
          </p>
          <p>
            Shadow opacity: <input type='range' min='0' max='1' value='0.5' step='0.1' class='slider' id='shad_op_range' />
            <input id="shad_op" class="opt_control" type="number" min='0' max='1' value="0.5" size="3"/>
            Shadow blur: <input type='range' min='0' max='50' value='0' class='slider' id='shad_blur_range' />
            <input id="shad_blur" class="opt_control" type="number" min='0' max='50' value="0" size="3"/>
          </p>
        </div>
      </div><div class="w3-panel w3-cell">
        <div class="w3-container w3-blue"><h3>Layout</h3></div>
        <div id="layout_opts">
          <p>Line spacing: <input type='range' min='0.5' max='2' step="0.1" value='1' class='slider' id='line_spacing_range'/><input id="line_spacing" type="number" class="opt_control" value="1" size="3" />
          </p><p><div class="percentage">Vertical margin: <input type='range' min='0' max='100' value='1' step="0.1" class='slider' id='v_margin_range'/>
            <input id="v_margin" type="number" min='0' max='200' class="opt_control" value="0" size="3" /> % of height of video<span class="tooltiptext"></span></div>
          </p><p><div class="percentage">Horizontal margin: <input type='range' min='0' max='100' value='1' step="0.1" class='slider' id='h_margin_range'/>
            <input id="h_margin" type="number" min='0' max='500' class="opt_control" value="0" size="3" /> % of width of video<span class="tooltiptext"></span></div>
          </p><p><div class="percentage">Offset from bottom of screen: <input type='range' min='0' max='100' step="0.1" value='0' class='slider' id='v_offset_range'/>
            <input id="v_offset" type="number" class="opt_control" min='0' max='100' value="0" size="4" /><span class="tooltiptext"></span> % of height of video<span class="tooltiptext"></span></div>
            <div id="horiz_off"></p><p><div class="percentage">Offset from <span id="horiz_dir">left</span> of screen: <input type='range' min='0' max='100' step="0.1" value='0' class='slider' id='h_offset_range'/>
              <input id="h_offset" type="number" class="opt_control" min='0' max='100' value="0" size="4" /> % of width of video<span class="tooltiptext"></span></div>
            </div>
            </p>
            <div id="width_div"><span id="bg_width_text">Background width</span>: <div class="percentage"><input type='range' min='0' max='100' step="0.1" value='0' class='slider' id='bg_width_range' />
              <input id="bg_width" class="opt_control" type="number" min='0' max='100' value="0.5" size="3"/> % of width of video<span class="tooltiptext"></span></div>
            </div>
            <p>
              Background type:
              <select id="bg_type" class="opt_control">
                <option value="full">Fixed width background</option>
                <option value="tight">Tight around text</option>
                <option value="none">No background</option>
              </select>
            </p>
            <div class="subpanel"><p>
            <div id="bg_options">
              Background colour: <input class="opt_control" type='color' id='bg_colour' value='#ffffff'/>
              Background opacity: <input type='range' min='0' max='1' value='0.5' step="0.1" class='slider' id='bg_opacity_range' />
              <input id="bg_opacity" class="opt_control" type="number" min='0' max='1' value="0.5" size="3"/>
            </div></p></div></div>
          </div>
        </p>
        <div class="w3-panel">
          <div class="w3-container w3-blue"><h3>Global options (apply across all styles)</h3></div>
          <div>
            <input id="bg_visible" class="w3-check opt_control global" type="checkbox"/><label>Keep background visible even where there is no lyric text?</label>
          </div><div>
            <span id="overlay_wrapper"><input id="universal_overlay" class="w3-check opt_control global" type="checkbox" checked/><label>Make background consistent height across all styles? (Useful if font sizes change between styles)</label>
            </span></div><div>
              <input id="min_height" class="w3-check opt_control global" type="checkbox" checked/><label>Make overlay minimum possible height? (If you untick this, the transparent overlay will be the same height as the base video, for ease of alignment in your editor, but the file will be bigger)</label>
            </div>
            <div>
              <input id="fades" class="w3-check opt_control global" type="checkbox"/><label>Fade in and out when there are gaps in the lyrics? (Warning â€“ may significantly increase processing time for long videos. If you run out of memory, use the failsafe home download option)</label>
            </div><div id="fade_div">Fade duration: <input type='range' min='0' max='2' value='1' step="0.1" class='slider' id='fade_dur_range' />
              <input id="fade_dur" class="global opt_control" type="number" min='0' max='2' value="1" size="3"/>
            </div>
          </div>
          <div id="saving">
            <button class="w3-btn w3-black" id="reset_opts" type="button">Reset to default styleset</button>
            <button class="w3-btn w3-blue" id="save_opts" type="button">Save as new default styleset</button>
            <p>
              <button class="w3-btn w3-red" id="wipe_opts" type="button">Factory reset (wipe all saved styles)</button>
            </div>
          </div>
          <div id="export" class="tab_option" style="display: none;">
            <h2>Export your file</h2>
            <p>There are various ways to export your lyrics. In order of simplicity:</p>
            <h3>Recommended: export as video overlay</h3>
            <p>
              <details>
                <summary>Advanced options (try changing these if something doesn't work)</summary>
                <p>
                  Codec to use:
                  <select id="codec">
                    <option value="quicktime" selected>QuickTime animation (fast export, fairly widely supported)</option>
                    <option value="prores">ProRes 4444 (slower export, may be supported where QuickTime is not)</option>
                    <option value="ayuv">AYUV (very fast, apparently quite compatible on Windows but not Mac)</option>
                    <option value="v408">V408 (like AYUV but for Mac)</option>
                  </select>
                </p><p>
                  Frame-rate handling:
                  <select id="rate">
                    <option value="vfr" selected>Variable framerate: fast output and small filesize, but possible compatibity issues</option>
                    <option value="cfr" >Constant framerate: slower, should be more compatible, but on long videos you may run out of memory</option>
                    <option value="rate">Don't specify: leave choice to the codec (probably a bad idea)</option>
                  </select>
                </p><p>
                  Note: variable frame-rate changes the framerate for each subtitle â€“ this means that if a subtitle is displaying for a long time you can end up with absurdly low framerates like 0.01fps, which some video editors will reject (I'm looking at you, Final Cut Pro). If this happens, change to constant framerate instead, but be warned that memory usage will go up and the processing will slow down a lot.
                </p><p>
                  <button class="w3-btn w3-green" id="save_codec" type="button">Save as default settings</button>
                </p>
              </details>

            </p><p><button class="w3-btn w3-blue" id="browser_overlay" type="button">Export video overlay from browser</button><div id="ffmpeg_loading" style="color: red;">Recommended: export as video overlay (still loading, please be patient...)</div></p>
            <div id="ffmpeg_info">
              Progress of export: <div class="w3-border"><div id="ffmpeg_bar" class="w3-blue" style="height: 24px; width: 0%"></div></div>
              <input id="show_log" class="w3-check opt_control" type="checkbox" />Show export log: <div id="ffmpeg_log" class="lyrics_array" style="height: 200px; font-family: monospace; white-space: pre; overflow: scroll;"></div>
            </div>
            <p>This will use your browser to create an overlay of the lyrics. All formatting should be perfectly preserved (let me know if it isn't, and I'll try to fix it). You can then add this to the original video in your editor. It is exported in a format that supports transparency; this might not be viewable in your usual video player (it won't open in Apple QuickTime, for example), but the editor should be able to open it.</p>
            <p>The editor will autosave your lyrics when it starts an export, so don't worry - if the export crashes (as it might on a long file with particular settings), when you reload the page it will restore your lyrics so you can try again with different settings.</p>
            <p>The fact that this is possible is thanks to the amazing efforts of <a href="https://bgrins.github.io/videoconverter.js/">Brian Grinstead</a>, who somehow (a number of years ago) managed to compile FFMPEG (a desktop video processor) to run on your browser using Javascript. What a guy.</p>
            <h3>Quick: Subtitle file export options</h3>
            <p>This is very quick, but will require you to assemble the result yourself using an editor or processor that supports subtitle files (most do, to varying extents). Some formatting information may be lost.</p>
            <button class="w3-btn w3-blue" type=button id="export_srt">Export lyrics as SRT file</button> (SRT files are widely accepted, but don't contain any formatting information.)
            <p />
            <button class="w3-btn w3-blue" type=button id="export_ass">Export lyrics as ASS file</button> (ASS files contain most formatting information, but not all readers can use this information â€“ FFMPEG can though, mostly. Note that at present only the default style is exported.)
            <p />
            <h3>Failsafe: download materials to use FFMPEG on your system</h3>
            <p>
              If the browser overlay export doesn't work (eg. it runs out of memory), or you don't have an easy way to merge the overlay with the video on your own computer, you can download everything you need to process the video on your own computer, as a Zip file. The command you need will be copied into a text-box below.
            </p><ul><li>First you need to <a href="https://ffmpeg.org">install ffmpeg</a> on your own computer (<a href="http://blog.gregzaal.com/how-to-install-ffmpeg-on-windows/">here is a guide to installing on Windows</a>, and <a href="https://github.com/fluent-ffmpeg/node-fluent-ffmpeg/wiki/Installing-ffmpeg-on-Mac-OS-X">here is a guide for Macs</a>).
            </li><li>Then decompress the downloaded 'diy_overlay.zip' file and add your source video file to the resulting folder.</li>
            <li>Open a command window inside that folder (using a <a href="https://www.thewindowsclub.com/how-to-open-command-prompt-from-right-click-menu/">command or PowerShell window on Windows</a> or <a href="https://www.howtogeek.com/210147/how-to-open-terminal-in-the-current-os-x-finder-location/">the terminal on Mac</a>).</li>
            <li>Finally, copy and paste the command from the text-box below into the command window, and press return.</li>
            <li>The processed video will appear in the folder as 'overlay.mp4'.</li></ul>
            <p>

              <div><input id="just_overlay" class="w3-check" type="checkbox" selected/><label>Export just overlay? (If checked, the command will create an overlay using the codec and framerate settings above. If unchecked, the command will process the whole video as H.264.)</label>
              </div>
              <button class="w3-btn w3-blue" type=button id="home_ffmpeg">Download DIY materials for FFMPEG</button>
              <div id="command"><div id="confirmation"></div>FFMPEG command: <input id="ffmpeg_command" size="100" value="The command will be generated when you press the button above."/></div>
            </p>
            <h3>Experimental: Export full video from browser</h3>
            <p>If you're very patient and have a fast computer (and lots of memory), you can try to process the whole video using your browser. I don't recommend this unless you don't have any other way of putting the video together. It is <b>very</b> likely to run out of memory and give up, or at the very least to take an extremely long time. You have been warned!</p>
            <button class="w3-btn w3-red" id="browser_full" type="button">Experimental: export full video in browser</button>
          </div>
        </body>
        </html>
